### 个人信息

姓名：牛鹏杰
学历：本科
工作年限：1年
电话：13260767651
邮箱：niupj73@163.com
求职意向：java 后端开发

### 个人亮点

1. 有较强的文档阅读能力，曾阅读 Mybatis Plus、Redisson、Spring Cloud Gateway、Dubbo、Etcd、ZooKeeper等技术的官方文档自学，并运用到项目中。
2. 有较强的问题解决能力，能够利用 GitHub Issues 区、AI 工具、搜索引擎、Stack Overflow 等自主解决问题。
3. 有较强的调研分析和系统设计能力，曾参考 Dubbo 的设计方案，自主设计实现了一款高性能 RPC 框架。

### 专业技能（加粗，提前埋点）

1. 熟悉 Java，比如常用类库、集合类、并发、反射、注解、IO流、JDK 序列化、异常处理、网络编程等；能熟练运用 Lambda 表达式、Hutool 工具库编程，使用 JUnit 编写单元测试；能熟练运用反射、SPI机制、动态代理提升项目的可扩展性。
2. 熟悉 SSM + Spring Boot 框架，能够使用 MyBatis Plus + MyBatis X 自动生成基础 CRUD 代码；能够独立开发基于 SpringBoot Starter 的 SDK。
3. 熟悉 MySQL 数据库及库表设计，能够通过创建索引、Explain 分析等方式优化性能。
4. 熟悉 Redis，实践过基于 Redis 的分布式缓存、分布式 Session 登录、基于 Redisson 的分布式锁。
5. 熟悉分布式应用开发，比如 Dubbo RPC 框架、Nacos 和 Etcd 注册中心、负载均衡、设计重试和容错机制保证服务稳定性；而且能使用 Spring Cloud Gateway 实现 API 网关、访问控制；能够基于 Vert.x 反应式框架实现高性能的 HTTP / TCP 服务器和客户端等。
6. 熟悉常见业务问题的解决方案，比如数据批量导入、基于标签的查询、缓存预热、定时任务、正向 / 反向代理、全局跨域解决、多环境问题解决、API 签名认证、用户权限管理等。
7. 熟悉并实践过多种设计模式、比如工厂模式、装饰者模式、双检锁单例模式、代理模式等。
8. 熟练使用IDEA、Git、Markdown 语法、ChatGPT、Swagger、Navicat、浏览器控制台等工具提高开发协作效率。

**主要工作：** **（负责了哪个模块，用什么技术解决了什么问题，写具体的优化点，比如时间 从2s 到 200ms，多少条SQL）**

1. SQL 优化：查询时间从 2s 下降到 200ms，从查整张表改为查几个关键字段



### 项目经历

**简快接口平台**                                                                                  https://github.com/qisande/efast-api-backend

**项目介绍**

基于 Spring Boot + Dubbo + Gateway 的 API 接口开放调用平台。

管理员可以发布接口，可视化各接口调用情况；用户可以开通接口调用权限、浏览接口及在线调试，并通过客户端 SDK 轻松调用接口。

**主要工作：**

1. 根据业务流程，将整个项目后端划分为 web 系统、模拟接口、公共模块、客户端 SDK、API 网关这 5 个子项目，并使用 Maven 进行依赖管理和打包。
2. Spring Boot 项目模板快速构建初始 web 项目，并实现了基于 AOP 和注解的权限管理和日志、异常处理、跨域等基础能力。
3. 基于 MyBatis Plus 框架的 QueryWrapper 实现对 MySQL 数据库的灵活查询，并配合 MyBatis X 插件自动生成后端 CRUD 基础代码，减少重复工作。
4. 为防止接口被恶意调用，设计 **API 签名认证**算法，用户注册时为用户分配唯一 ak / sk 以鉴权，保障调用的安全性、可溯源性（指便于统计接口调用次数）。
5. 为解决开发者调用成本过高的问题（须自己使用 HTTP + 封装签名去调用接口），基于 Spring Boot Starter 开发了客户端 SDK， **一行代码** 即可调用接口，提高开发体验。
6. 选用 Spring Cloud Gateway 作为 **API 网关**，实现了访问控制、流量染色、路由、日志，并集中处理签名校验、请求参数校验、接口调用统计等业务逻辑，提高安全性的同时、便于系统开发维护。
7. 基于 nacos 注册中心和 Dubbo RPC，解决了跨模块方法调用的问题，就像调用本地方法一样简单。
8. 单机 8 核 16 线程，16G 内存，QPS 达到了 513/sec。



**高性能 RPC 框架**                                                                                                   https://github.com/qisande/q-rpc	
**项目介绍：**

基于 Java + Etcd + Vert.x + 自定义协议实现。开发者可以引入 Spring Boot Starter，通过注解和配置文件快速使用框架，像调用本地方法一样轻松调用远程服务；还支持通过 SPI 机制动态扩展序列化器、负载均衡器、重试和容错策略等。

**主要工作：**

1. 核心架构：包括消费方调用、序列化器、网络服务器、请求处理器、服务注册器模块。
2. 网络服务器：基于 Vert.x 的 HTTP 服务器，实现服务提供者和消费者的高性能网络通信。
3. 服务注册器：使用线程安全的 ConcurrentHashMap 存储本地服务注册信息，可以根据服务名称获取到对应实现类，并通过反射完成方法调用。
4. 序列化器：为便于扩展，编写通用的序列化器接口，并基于 Java 原生的 Object 和 ByteArray 输入输出流实现 JdkSerializer 序列化器，使得对象能够网络传输。
5. 请求处理器：基于 Vert.x 的 Handler 接口实现对请求的异步处理，将请求数据反序列化后，从服务注册器中找到服务实现类并通过反射机制调用。
6. 消费方调用：基于 JDK 动态代理 + 工厂模式实现，为指定服务接口类生成可发送 HTTP 请求的代理对象，实现远程方法的无感知调用。



**趣友阁**                                                                                                http://110.41.86.79:8100/api/doc.html#/home

**项目介绍**

基于 Vue 3 + Spring Boot 2 的移动端网站，实现了用户管理、按标签检索用户、推荐相似用户、组队等功能。

**主要工作**

> 根据自己的方向选择去写并适当调整文案，灵活一点。 强烈建议结合下面的扩展思路多完善下项目，增加一些区分度！

1. 用户登录：使用 Redis 实现分布式 Session，解决集群间登录态同步问题；并使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）
2. 对于项目中复杂的集合处理（比如为队伍列表关联已加入队伍的用户），使用 Java 8 Stream API 和 Lambda 表达式来简化编码。
3. 使用 Easy Excel 读取收集来的基础用户信息，并通过自定义线程池 + CompletableFuture 并发编程提高批量导入数据库的性能。实测导入 100 万行的时间从 xx 秒缩短至 xx 秒。（需要自己实际测试对比数据）
4. 使用 Redis 缓存首页高频访问的用户信息列表，将接口响应时长从 xx 秒缩短至 xx 秒。且通过自定义 Redis 序列化器来解决数据乱码、空间浪费的问题。
5. 为解决首次访问系统的用户主页加载过慢的问题，使用 Spring Scheduler 定时任务来实现缓存预热，并通过分布式锁保证多机部署时定时任务不会重复执行。
6. 为解决同一用户重复加入队伍、入队人数超限的问题，使用 Redisson 分布式锁来实现操作互斥，保证了接口幂等性。
7. 使用编辑距离算法实现了根据标签匹配最相似用户的功能，并通过优先队列来减少 TOP N 运算过程中的内存占用。
8. 自主编写 Dockerfile，并通过第三方容器托管平台实现自动化镜像构建及容器部署，提高部署上线效率。
9. 使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。

1. 选用 MyBatis + MyBatis-Plus 进行数据访问层开发，复用大多数通用方法，并且通过继承定制了自己的 **通用操作模板** ，大幅提升了项目开发效率。
2. 为了明确接口的返回，自定义统一的错误码，并封装了 **全局异常处理器** ，从而规范了异常返回、屏蔽了项目冗余的报错细节。
3. 对于项目中的 JSON 格式化处理对象，采用 **双检锁单例模式** 进行管理，从而复用对象，避免了重复创建对象的开销，便于集中维护管理。（双检锁单例模式的实现非常简单，大家百度一下示例代码即可）
4. 采用 Docker 容器完成后端项目部署，并且使用宝塔面板对项目进行运维监控。
5. 使用 JUnit Jupiter API 的 @Test 注解和 Assertions 类实现对用户模块的单元测试，测试覆盖度达到 90%。
6. 通过 Spring Boot 的多套 application-{env}.yml 配置文件实现多环境，并通过指定 --spring.profiles.active=prod 实现生产环境部署。
7. 单机 8 核 16 线程，16G 内存，QPS 达到了 457/sec。

### 教育经历

**南京信息职业技术学院**	                              数控	                              专科	                              2017~2020

**南京信息工程大学**                                             自动化                                   本科                                      2020~2022

### 工作经历

七四九（南京）电子研究院有限公司

软件开发部  Java后端开发工程师 南京

**后端定制化开发：**负责根据产品需求，进行后端系统的定制化开发。确保后端服务的稳定性、可扩展性和安全性。

**接口封装：**对应用的基础数据据进行封装，简化外部调用。设计和实现的数据接口封装，提升数据交互的效率。

**接口对接：**负责与第三方系统（如健康打卡平台、门禁系统、财务系统、邮件、短信及验证码等）的接口对接工作。

**数据库优化：**针对数据库中的慢查询，进行EXPLAIN查看执行计划，并优化或添加索引来提高查询效率或重构查询。

**压测与分析：**针对内部或即将上线的高并发业务，进行压测。根据分析结果，制定优化计划，持续提升系统性能。

**文档编写与维护：**编写和维护设计文档、接口文档和用户手册。确保文档的准确性和易理解性，以支持团队和用户。



**XXXXXX学校网上办事大厅**

2020-10~2024-05 开发工程师兼项目负责人

项目描述：本项目旨在通过公司平台快速开发，为学校完成各种定制化的工作流业务，提高校园业务处理的便捷性和效率。

项目职责描述：我的项目职责包括需求调研、功能开发、软件测试以及用户手册编写，确保从理解客户需求到提供高质量产品和文档的每个环节都准确无误。

重点业务：

普通话报名（含支付）：为了解决原有单节点后端服务在高并发情况下的性能瓶颈，采取了一系列优化措施：

·服务扩展：将后端服务从单节点扩展到多节点，以提高系统的处理能力和稳定性。

·引入Redis：使用Redis缓存用户基础数据，减少对MySQL数据库的直接访问，加快数据读取速度。

·分布式锁：通过分布式锁机制，确保在多节点环境下数据的一致性，解决名额控制和订单失效等问题。

·异步调用：通过定时任务异步调用第三方支付接口，避免因第三方接口性能问题影响主服务的响应时间。

·支付订单处理：创建支付订单的流程改为异步处理，并对失败的订单实施自动重试机制。

·错误通知：当订单重试超过设定次数后，系统会自动通过邮件通知运维人员，以便及时介入处理。

·性能提升：通过上述改造，并通过Jmeter测试，系统的QPS（每秒查询率）从50提升至约200（单机），显著提高了系统性能。

·补充功能：为了提高系统管理员处理大量报名附件的效率，系统引入了CompletableFuture来异步执行附件的批量下载任务。通过CompletableFuture.allOf判断所有的下载任务是否完成并进行后续压缩操作。

校外人员进校预约：校外人员进校预约系统为学校提供了一套全面的访客管理解决方案旨在提升校园安全和访客体验身份验证：系统通过手机号和短信验证码进行身份校验，确保用户身份的真实性。Redis用于存储验证码，并设置12

# 简快接口平台

三张表：用户表、接口表、用户接口关系表

两条线：

第一：管理员

用户的增删改查（注册（分配ak、sk）、登录（利用 redis 来存储登录态）、注销）

管理员对接口信息进行增删改查（发布接口、上线接口、下线接口、删除接口、调用接口，统计调用次数前三的接口）

用户接口关系增删改查（开通接口、查看接口、调用接口）

第二：用户

用户通过 SDK 直接调用方法，通过 Hutool 工具包向网关发送 HTTP 请求，获得结果后返回给用户。根据请求内容生成签名，并在请求头中添加签名。

网关拦截请求后，第一打印日志；第二，通过签名来鉴权；第三，路由到真正的接口地址上；第四，调用接口后，更新接口调用次数。第五，返回结果给用户。

网关通过 dubbo 调用后台管理的方法（获取接口信息、调用次数加一、获取开通接口的用户信息）



技术点：

API 签名认证

SDK 开发

Spring Cloud Gateway 的使用

Dubbo RPC 框架的使用

# 高性能 RPC 框架

RPC 是一种计算机通信协议，允许一个程序像调用自己的方法一样，调用另一个程序的接口，而不需要了解数据的传输处理过程、底层通信细节。

消费者想要调用提供者，需要提供者启动一个 web 服务，然后通过请求客户端发送 HTTP 请求或者其他协议的请求来调用。RPC 就是提供一个统一的服务调用接口，通过请求处理器根据客户端的请求参数来进行不同的处理、调用不同的服务和方法。

具体实现就是服务提供者维护一个本地服务注册器，记录服务和实现类的映射。然后请求处理器请求参数中的服务名从服务注册器中找到对应的服务实现类，并通过 Java 反射机制调用请求参数中的方法名指定的方法。

具体模块：

**全局配置加载**：

目的：

配置信息太多需要进行统一管理。通过编写配置文件来自定义配置，同时维护一个全局配置对象，便于快速获取到配置。

具体实现：

1. 读取配置文件：编写工具类，通过 Hutool 的 Setting 模块，直接读取指定名称的配置文件，并转化为 Java 对象。

2. 维护全局配置对象：在 RPC 项目启动的时候，使用双检锁单例模式创建配置对象实例，集中的从这个对象中获取配置信息，避免重复创建对象，减少性能开销。

**序列化器和 SPI 机制**：

目的：

Java 对象存活在 JVM 虚拟机中，如果想在网络中进行传输，就需要序列化和反序列化。同时能够让框架的开发者定制序列化器、指定序列化器。

具体实现：

首先是不同序列化器的具体实现，其次使用自定义的 SPI 机制，支持用户自定义序列化器并指定键名。

使用 Hutool 工具包的 ResourceUtil 读取资源文件，将实现类保存到 HashMap 中。创建序列化器工厂，当需要实例的时候，使用反射机制获取到实现类的对象。

**注册中心实现**：

目的：

帮助服务消费者获取到服务提供者的调用地址，而不是将地址硬编码到项目中。

具体实现：

注册中心使用 Etcd，并实现初始化、服务注册、服务注销、服务发现、服务销毁等方法。可以利用 SPI 机制自定义或指定不同的注册中心。服务消费者使用代理并调用服务发现方法从注册中心获取到服务提供者的地址，之后可以根据地址发送请求，并拿到响应后的数据。

通过续期机制来实现心跳检测，保证及时更新注册中心，剔除下线节点。

消费端增加本地缓存。在进行服务发现时，拿到服务信息后缓存到本地，并且优先从缓存获取服务。同时监听 key 的变化，当注册中心清理缓存后，本地也及时清理缓存，保证数据一致性。

**自定义协议**：

目的：

HTTP 协议的头部信息和格式较为冗余，影响网络传输性能。需要自定义消息结构和网络传输。

具体实现：

网络传输选择 TCP 协议，消息结构包括请求头和请求体，请求头包括魔数（安全性保证）、版本号、序列化器、消息类型、状态、请求 id、消息体长度。

发送请求前使用编码器将消息对象转换为 Buffer，接收消息后使用解码器将 Buffer 转换为消息对象。

请求发送：

服务消费者通过服务代理发送请求。

第一，构造请求；第二，从注册中心获取请求地址；第三，构造消息对象；第四，编码消息对象；第五，发送 TCP 请求；第六，接受响应；然后解码为消息对象。

请求处理器：

服务提供者通过请求处理器接受请求并调用服务。

第一，接受请求并解码为消息对象；第二，通过反射调用服务实现类；第三，封装响应结果；第四，构造消息对象；第五，编码；第六，发送响应。

**负载均衡**：

目的：

减轻单个节点的压力，利用好其他节点的资源。确保每个资源都能有效的处理负载，增加系统的并发量。

具体实现：

有轮巡、随机、一致性 Hash 等算法来实现负载均衡。

使用服务器地址来计算 Hash 值，并引入虚拟节点，将服务器节点均匀的分散到整个 Hash 环上。

**重试机制**：

目的：

在调用接口失败后，使得服务消费者拥有自动重试的能力，提高系统的可用性。

具体实现：

引入 Guava-Retrying 库，使用 Guava-Retrying 提供的 RetryerBuilder 来指定重试条件、重试等待策略、重试停止策略等。比如当发现异常时重试，固定 3s 重试一次，超过 3 次后停止重试。

**容错机制**：

目的：

消除偶发、单点故障对系统带来的整体影响。

具体实现：

容错有多种方式，比如降级、熔断、限流、快速失败、静默处理等，可以先重试后容错。在重试多次抛出异常时，获取容错策略并执行，比如静默处理。

**启动机制**：

目的：

让框架更易用，帮助开发者最少只用一行代码，就能轻松使用框架。

具体实现：

服务提供者利用 @RpcService 注解，并实现 BeanPostProcessor 中的方法，将服务注册到本地和注册中心。

服务消费者利用 @RpcReference 注解，并实现 BeanPostProcessor 中的方法，先生成代理对象并注入到属性中。



技术点：

启动机制

序列化器和 SPI 机制

# 趣友阁

帮助大家找到学习伙伴，包括按标签搜索用户、建房组队、推荐相似用户等功能。



技术点：

单点登录

推荐用户，缓存预热

相似度算法



