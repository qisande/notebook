## 面试：

1. 自我介绍：

   我是...

2. 八股文

   1. Java 基础
   2. Java 集合
   3. Java 并发
   4. Java 虚拟机
   5. MySQL
   6. Redis

3. 项目（要有亮点）

   1. 介绍一下项目

      简短，介绍一下有什么模块，模块之间是怎么调用的

   2. 你负责了哪个模块，这个模块是干什么的

   3. 就某一个技术点会深入，问为什么使用这个技术，不用其他技术，用它解决了什么问题

4. 可能有算法




## API 开放平台项目介绍



## API 开放平台模块介绍



## 面试题：

#### 你的项目中使用了哪些技术栈？请分别介绍一下SpringBoot、Dubbo、Gateway在项目中的作用

#### 你将后端项自划分为了多个子项目，请分别介绍这几个子项目的作用、以及它们之间是如何协作和交互的？

#### 请简要介绍Maven的基本概念、作用以及如何使用Maven进行多模块依赖管理和打包？

#### 请介绍一下你是如何使用MyBatisPlus框架的QueryWrapper实现了对MySQL的灵活查询？

#### 什么是OpenAPI规范？它有什么作用或好处？

#### 你在项目中使用了Swagger+Knife4j自动生成接口文档，请谈谈Swagger和Knife4j的作用和它们对项目开发的影响

#### 什么是API签名认证算法？它有什么作用？你又是如何实现它的

#### 你在项目中使用了SpringCloudGateway作为API网关，请解释一下API网关的应用场景，以及它在项目中的实际应用？

#### 你是如何基于SpringBootStarter开发了客户端SDK的，讲述一下实现过程？

#### 用户如何使用你开发的客户端SDK？讲述一下流程

#### 有哪些客户端SDK的设计技巧？

#### 什么是RPC？为什么要使用DubboRPC框架它有什么优势？

#### 你在项目中是如何使用DubboRPC框架的，讲述一下使用流程？

#### 你在公共模块中抽象了模型层和业务层代码，请解释一下模型层和业务层的概念，并说明抽象公共模块的自的和好处

#### 你通过API网关实现了流量染色技术，请介绍一下流量染色的概念、以及它的作用？

## 真实面经

#### 介绍一下api项目和伙伴匹配项目

#### 如何开发的客户端sdk？解释了一通，感觉这个面试官似懂非懂.....

#### API签名认证算法是怎么做的？

#### 如何进行鉴权的？

#### 管理员是怎么可视化各接口的调用情况的？



#### 项目的人员分工以及项目需求的分工是如何划分的？

#### 13.2. 介绍一下这个项目及这个项目中比如说分哪些模块，然后你是做了哪个模块。

#### 13.3. 在这个做的过程中，感觉有没有什么比较头疼的问题？

讲了鉴权功能

#### 13.4. 是个比较通用的，还是之前遇到过什么？做那个什么优化。

比较通用的一个功能

#### 13.5. 那你还搞了个网关，为什么当时为什么想搞这玩意儿？

为了鉴权以及统一处理请求并进行负载均衡（然后发散讲了一些）

#### 13.6. 为什么要做转发？

因为项目是不同模块的划分，为了实现统一的鉴权，做一个网关实现路由转发来是完成

#### 13.7. 聊到外层的模块和你的客户端的模块，对吧？那你能大概说一说你用到哪些技术吗？

#### 13.8. 它最后是怎么样去连接数据库的吗？到底是用了哪个工底层的工具来连接数据库的呢？

#### 13.9. 你可以稍微讲一下你的业务，你可以稍微讲一下你负责的业务？

#### 13.10. 你这边有登录注册，修改密码这些，那就是你支持一个账号在多个地点登录？

#### 13.11. 同时登录以后，有个人有一个账号对密码做了修改，那其他的账号会不会被踢掉呢？

#### 13.12. 也聊到你这边有上线下线接口，这个你是怎么实现的？

#### 13.13. 这个上线下线接口有什么用呢？下线之后不能使用是如何做到的？

#### 13.14. 你现在上线和下线接口的时候，就比如说刚刚你不是你客户端可以在多个地方登录。那这个时候就比如说A登录了也B也登录了，对吧？然后假设A对一个接口进行上线，然后B同时对这个接口进行下线，那你怎么样保证他们的操作是有序的？

#### 13.15. 整个这个项目的过程中，就是你觉得对你来说挑战比较大的一个事情是什么？

比如在设计实现 API 签名认证算法时，发现鉴权结果和预期不同 —— ak、sk 明明完全一致，但就是无法通过鉴权。然后你通过 debug 的方式，定位到了关键问题是由于中文编码、或者字段大小写不一致导致了签名不同。最后你通过修改中文编码等方式确保客户端和服务端生成的签名一致进行解决。

#### 13.16. AK和SK是如何来实现用户的鉴权的呢

#### 13.17. 你的第一个项目，你有去风控过他们的发帖子的内容吗？有去监控过他们的帖子发帖内容吗？

实现对帖子内容进行风控是一个相对复杂的问题，需要综合考虑多个方面，包括文本分析、规则引擎、机器学习等技术手段。下面是一种常见的实现思路：

1. 敏感词过滤：建立一个敏感词库，包含一些不允许出现的关键词或短语。对新发表的帖子内容进行敏感词过滤，如果检测到敏感词，则拒绝发布或进行相应处理。
2. 文本分类与文本匹配：利用机器学习或自然语言处理技术，对帖子内容进行分类，如骚扰广告、色情等。可以采用传统的分类算法或深度学习模型来训练分类器，并将新的帖子输入分类器中进行分类预测。
3. 文本相似度匹配：对于重复发布或高度相似的帖子，可以通过计算文本相似度或采用哈希算法来发现重复内容，减少重复帖子的出现。
4. 用户行为分析：基于用户的历史行为数据（如发帖频率、点赞、评论等），建立用户行为模型。通过分析用户行为模式，可以检测出一些异常行为，如恶意刷屏、灌水等，进而实施相应的风控措施。
5. 人工审核与用户举报：引入人工审核机制，在发帖后对帖子内容进行人工审核。同时，也鼓励用户积极举报违规内容，通过用户反馈来进行风控处理。
6. 不断更新与优化：不断收集数据并进行分析，优化现有的风控策略和算法，以应对新的风险。

需要注意的是，风控系统的设计与实现是一个综合性的问题，需要根据具体的业务需求、用户行为和平台特点进行定制化开发。同时，也需要遵守相关的法律法规与隐私保护政策，确保用户的合法权益和数据安全。

#### 13.18. 你做这个项目之前，你有去了解过市场上其他平台的这种项目吗？还是说你自己独立设计的？

#### 13.19. 你在里面负责什么内容？你觉得你负责的模块里面最难的是哪一部分？

#### 13.20. 你这个项目的Dubbo用在了哪里？

#### 13.21. 你为什么要把一个业务砍都砍出这么多模块出来？是用什么来去根据什么来划分这些模块的？

#### 13.22. 你说你可以直接集成这个客户端SDK，那我API网关怎么统计你对这个客户端的调用情况呢？

#### 13.23. 如果客户端安装自己的SDK的话，你客户端SDK更新了以后，你怎么怎么做一个适配或者说发布

#### 13.24. 可能解决不了适配问题。比如说我有一个接口，我原来只要传三个参数，我老的业务只支持三个参数。那后面业务发生变动了，我需要传四个参数，那四个都是必传的那我新版的SDK发布了，我怎么让老的用户去使用我的新的SDK，或者说我怎么去把这个老APP适配掉？

#### 13.25. 你当时写这个平台的时候，是为什么要写这个平台？你有去网上搜过这种在线接口平台的相关项目吗？

#### 13.26. 那你现在专业接口平台第一版设计的时候，你都设计了哪些接口？

#### 这个项目写完以后，你自己最大的收获是最大收获？

#### 13.28. 如果用过的SKAK泄露了怎么办？他用一个正常的AK使劲访问你，你有下线的操作吗？

#### 13.29. 你那你对这个接口的请求频率什么之类的有做限制吗？如何实现的？

#### 13.30. 项目的代码都是你自己写的吗？负责了哪些模块？

#### 13.30.1. API虚拟认证算法是个什么？可以大概讲一下如何实现的吗？

#### 13.31. 当然，除了MD5加密，市面上还有多种加密方式，这些加密方式根据应用场景和安全需求的不同而有所区别。以下是一些常见的加密方式：

#### 13.31.1. 其他加密方式

1. **对称加密算法**：

- - **AES（Advanced Encryption Standard）** ：目前广泛使用的对称加密算法，提供高安全性。
  - **DES（Data Encryption Standard）** ：较老的对称加密算法，虽然安全性不如AES，但在一些旧系统中仍然使用。
  - **RC4**：一种流加密算法，速度较快，但安全性存在争议，不推荐在新系统中使用。

1. **非对称加密算法**：

- - **RSA**：最常用的非对称加密算法之一，用于加密小量数据、数字签名等场景。
  - **DSA（Digital Signature Algorithm）** ：主要用于数字签名，确保数据的完整性和发送者的身份。
  - **ECC（Elliptic Curve Cryptography）** ：基于椭圆曲线数学的加密算法，提供与RSA相同的安全性，但密钥长度更短，计算效率更高。

1. **散列函数**：

- - **SHA（Secure Hash Algorithm）** ：包括SHA-1、SHA-256、SHA-3等，广泛用于数字签名、文件校验等场景。
  - **Bcrypt**：一种专为密码存储设计的散列函数，通过增加计算复杂度和盐值来提高破解难度。

1. **Base64**：

- - 严格来说，Base64不是一种加密算法，而是一种编码方式，用于将二进制数据转换为ASCII字符串形式，以便于在网络中传输。

#### 13.32. 可以简单介绍一下第一个项目的应用场景？

这主要是对于开一个软件开发的一个开发者来进行使用的。当然你用户的话，你也可以在线对一个对一些接口一些在线的一个调用。

主要对开发者来说的话，他可以对一些在这个平台上线的一些接口对进行一些。比如你有些功能需要一些接口，需要一些三方接口来实现。你可以在这个平台上来进行一些寻找。它会比如有一些你需要前端需要调用一个当日的每日的天气。在这个平台上你可以根据提供一个文档，在项目在自己的项目中进行一个接入。同时的话他也提供了一个SDK的一个工具包。本地的一个SDK你可以用开发者可以下载到本地，对这个项目进行一个整合到自己的项目中，大致是这样一个作用。

#### 13.33. 你这个项目相当于是整合了第三方的接口然后进行SDK的一个开发吗？

也可以三方来接入自己，也可以上线一些自己的原创的一些接口。相当于是一个平就是一个也可以理解为你那种对所有的接口进行一个聚合，包括三方的以及自己的一些接口。

#### 13.34. 本项目中你用到了Dubbo，请问在项目中起到了什么作用呢？

这个项目因为是分模块的，它在引入double它一个远程调用，对不同模块之间的一些接口进行一个远程的调用。可以个人开发者的话不用关心不同模块之间的一些远程的调用的传输协议，把它当成像本地方法一样实现不同模块间的调用。

#### 13.35. 像你这种分布式的项目，你怎么部署的？比如说我有五个子模块，它们有相互依赖的关系的话

#### 13.36. 那你先说一下在这个项目上面有没有让你觉得有挑战的地方？

因为这个项目我觉得学到更多的可能在AK和SK设计的那些那那一块。

你正常来说你我这个接口正常来说每个人调用的话，我不可能免费给你调用。一般来说是需要收费的。然后涉及到收费的话，你要就要采就要去就要防止一些用恶意用户来进行一个访问。这个时候我对每一个在我这个平台上注册的用户，我先注册，注册的时候已经给他生成一个默认，生成一个随机，生成一个AK和SK然后存到你的数据库里面。然后你如果要来访问我的数据库的时候，你要来访请求我这个接口的话，我会把请你把你的AK和一些请求头以及时间戳，或者加一些随机数，通过前通过这个请求头来进行一个加密算法。然后我们当时选的是MD5加密的。

加密完之后，如果因为我们是通过一个网关请求，请求都会统一进入到网关层。在网关层的话，它会通过你用户的ID然后查询到你这个数据库里面的AK通过AK然后再根据获得请求，请求头里面获取到那个随机数，以及你的请求的一个数据以及随机数，然后再进行一个MD5加密。

MD5加密后的一个数据，如果相等的时候，你我这个API接口这个提供者才能信任你这个调对我这个接口调用的对他产生了信任，这时候才能进行调用，否则的话他就不允许他调用。这时候可以防止有一些用户，有一些恶意用户，比如获取到你这个伪造一个请求，然后来恶意的攻击我这个API。

你这个AK跟SK跟oauto的认证是同一套体系吗？

类似。因为我们当时参考的是腾讯云以及一些阿里云。他当时你如果想要使他第三方平台一些OSOSS那种对象存储的话，他会给你提供一个AK和SK。我们当时是通过这来思考的那我在登录的时候，

#### 13.37. 你们主要是在上面发布了哪些接口呢？

发布结果的话，我们有一些比如在线调试调在线桥每日的天气，以及根据一些就比如给一个相关的一个字段，然后返回你一个想要的一个图片吧。还有一些我们在别的一些我们当时写的别的项目，我们觉得可能后期会用到，然后就把这些封装到项上线到项目当中，然后可以对他进行后期一个项目开发进行一个复用。

#### 13.38. 就是你这边统计接口的调用次数是怎么统计的？

因为我们当时想的是有3种，因为正常来说你前我你前端如果要访问我这个项目的话，有一种情况是你前端可以直接访问我这个模拟的这个接口。然后还有一种是通过后端，你前端先到后端，然后再通过后端来访问这个模拟接口。这种情况的话可以用一些NGINX这种来进行一个负载均衡。

但是我们考虑到NGX可能编程的话更复杂一些。我们这时候用的是SpringBoot gataway, 然后你前端先通先访问接口的话，都会通过先会请求到API网关层。网关层在网关中统一对一个次数进行一个计算。你到这个接口的时候，你先对你要请求哪一个接口，然后对这个进行计算之后，通过网关层来通过网关层来对你这个路由统一进行转发。转发到你对应的有一个接口，有一个模拟接口的一个模块。通过这个模拟接口的模块就可以进行真实的一个对接口的请求，直接就在网关层进行数据统进行这个次数的统计。

#### 13.39. 涉及了API的签名认证的一个算法，给用户分配分分配了独立的那个AK用于健全，对吧？对，那那我想问一下你这个里面的话有没有防篡改相关的假设？

一般我们这个API签名认证算法的话，正常流程是你你你在注册的时候有生成这个AK和SK。你如果请求API的话，你会把这个AKAK1请求后等参数传过去。一般AK和SK是不可以被第三方获得的。你只传的时候只会传一个AK然后以及请求头以及时间戳还加了一个随机数，然后通过网关层来进行一个统一的拦截，然后进行健全。健全之后根据这个把根据请这个请求头这个加密的里面的获取到AK然后通过这个AK来查询它数据库里面真实的一个AK和SK，然后再进行一个MD5加密，然后两个对比之后才能如果相同的话，才能对这个请求者进行一个信任。如果中间人对他进行一个篡改的话，用用户如果觉得他这个用户如果觉得他这个请求的有一些异常的话，他他会申请对这个AK和SK进行一个重新生成。

对于数据的篡改并没有进行开发

#### 13.40. 您在设计这个签名认证算法的时候，有没有参考过一些业界的一些认证。

比如说类似于一下阿里云或者腾讯云。

因为阿里云跟腾讯云，如果因为当时我们如果存储图片的话，当时是刚开始考虑的是腾讯云，阿里云的对象存储。他是给你提供一个你想要使用的话，他给你提供一个AK和SK。你可以在本地进行一个进行一个配置，然后再在yml文件里面进行一个配置。配置完之后，你就可以对图片进行上传以及下载了。当时是可当时是根据他这方面来进行一个实现的。

#### 13.41. 您说解决多个子系统代码重复的问题，您抽象出了一些公共模块。那您具体抽象了哪些公共模块？然后抽象的一个原则是什么样子的？中间有没有用到什么样的一些设计模式？

因为我们这个公共模块层，它其实是包含了一些，就比如说各个模块有可能很多模块都需要使用到的一些实体类，还有一些公共场公共每个模块都要涉及到一些，就比如有一些方法类，或者就有一些封装的一些youtube那种封装的一些包，这些是在公共模块的。因为公共模块里面涉及的东西不是太多。当时分开的模块是主要是为了能够在因为我们当时的公共模块的话，如果要引用的话，是把它通过maven进行打包，然后在需要的模块里面进行引用就可以使用了当因为也模公共模块里面涉及到的东西也不是很多，也没有依据那个设计模式来划分。

#### 13.42. 通过RPC框架实现子系统间的高性能接口调用，然后的话您的接口调用大概有多少的QPS？

## RPC 项目介绍

这个项目功能就是让消费者利用 RPC 框架去调用提供者的服务，不用关心细节，就像调用本地方法一样简单。

调用流程为：消费者调用接口方法，利用动态代理生成接口的代理对象，代理对象利用请求客户端向提供者发送序列化后的请求。提供者的 web 服务器接收到请求后，利用请求处理器将请求反序列化，拿到请求中封装的服务名称、方法名、方法参数类型、具体参数等信息。利用反射调用服务的实现类的方法，拿到返回值，然后再将值封装为响应，发送给消费者。

## RPC 模块介绍

**全局配置：**

目的：将配置与代码解耦，方便用户定制化开发

在rpc项目启动时，获取到全局配置对象，利用Hutool工具包读取配置文件并生成配置对象，其中使用到了**双检锁单例模式**和懒加载机制。

好处？

这样的好处就是，可以集中管理配置，并减少对象创建。

为什么要用双检锁单例模式？

双检锁是为了保证操作的原子性，保证同一时间只能有一个线程来执行这个操作

什么是懒加载？

需要的时候才创建对象，避免浪费

**接口 Mock：**

目的：有的接口没开发完成，利用代理对象返回假的数据，利于调试，测试，可以快速打通整个开发流程。

**SPI机制：**

目的：实现模块化开发和插件化扩展

SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过反射机制动态加载这些实现，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。

一个典型的SPI应用场景是 JDBC （Java数据库连接库） ，不同的数据库驱动程序开发者可以使用JDBC库，然后定制自己的数据库驱动程序。

**序列化：**

目的：Java 对象不便于在网络传输，所以需要将 Java 对象转化为字节流。

有几种主流的序列化方式，分别是：

json、hessian、kryo、protobuf，这几种方式个有优劣，背一下，因为 json 的易读性好，便于理解和调试，且跨语言支持广泛，所有作为默认的序列化方式

**注册中心：**

目的：帮助消费者获取到服务提供者的地址，将 url 与代码解藕

提供者注册地址等信息到注册中心，消费者从注册中心获取信息，得到地址，通过地址对提供者发起调用

注册中心实现用的是 Etcd

提供者：主要功能是服务注册和心跳检测

服务注册就是将节点信息注册到注册中心

心跳检测是为了检验目标系统的状态，如果系统故障或不可用，从而出发相应的处理或告警机制

实现：用到了 Etcd 的续期机制，给 key 设置过期时间让节点定期续期，到时间没续期就知道服务挂了，将节点信息放到本地集合中，定期扫描集合重新注册。

消费者：主要功能是服务发现，本地缓存，监听机制

服务发现就是从注册中心拿到节点信息，从而去调用服务。将节点信息放到本地 Map 中缓存起来，方面下次使用。

监听机制：当节点信息变化了，需要去更新本地缓存，用到了 Etcd 的监听机制，监听到 key 发生变化时通知消费者。

**自定义协议：**

目的：HTTP 是一个更通用的协议，比较臃肿，而 RPC 模块是定制的，可以自定义更精简的请求头和响应头，减小体积，提高传输效率。

网络传输：采用 TCP 协议，更底层 （传输层）效率高

消息结构：用最少的空间传递必要的信息。

请求头：参考了 Dubbo 的协议设计。请求 id，请求体长度。

另外还需要编码器和解码器

编码器：创建缓冲区对象，将字节数组按顺序依次写入缓冲区

解码器：从缓冲区按顺序依次将字节数组读取

半包和粘包问题：

半包：每次收到的数据更少了

粘包：每次收到的数据更多了

半包解决：在请求头中设置请求体的长度，判断长度是否符合预期，不完整就留到下次再读取

粘包解决：只读取指定长度的数据，超过的留到下次读取

利用 Vert.x 的 RecordParser 来解决，为 Parser 指定读取固定长度的内容，如果请求体每次长度固定，则可以解决。

但是长度是变得，所有调整 RecordParser 读取时的长度，可以分两次来读取

1. 先读取请求头，长度固定，可以完整读取
2. 再读取请求体，根据请求体的长度信息，来设置 RecordParser 读取时的长度

**负载均衡：**

目的：如果有多个服务节点，利用负载均衡可以减轻单个节点的压力，使服务请求比较均匀的分布到各个节点上，增加系统的并发量

轮训：按照循环顺序将请求发配给每个服务器，适用于各服务器性能相近的情况

随机：随机选择一个服务器来处理请求，适用于各服务器性能相近且负载均衡的情况

一致性 Hash：每个节点或服务器，在环状结构上占据一个位置，将请求的哈希值映射到环上一个点，顺时针寻找第一个大于等于其值的点，路由到该节点上。为了使节点在环上更加均匀的分布，可以创建虚拟节点。

计算请求的方法名的 Hash 值，调用一致性 Hash 算法，根据 Hash 值，找到对应的节点，所以方法名相同总会请求到相同的节点上。

**重试机制：**

目的：有时可能会调用接口失败，为了提高系统的可用性，可以进行重试。

重试策略实现：固定重试间隔

使用 Gvava-Retrying 提供的 RetryBuilder 可以很方便的指定重试条件、重试等待策略、重试停止策略、重试工作等。

比如：发生异常时重试，等待 3s，重试 3次后停止，每重试一次还可以执行额外的任务。

**容错机制：**

目的：提高系统的可靠性和健壮性，比如重试一定次数后仍然失败，接下来由容错机制来处理。

重试机制也可以看成容错机制的一种，可以将各种策略来组合使用，比如：

1. 系统调用服务 1 实现网络错误，使用重试。
2. 重试几次失败后，使用降级，改为调用不依赖网络的服务2，完成操作。

1. 快速失败：直接抛出异常
2. 静默处理：直接返回响应

**启动机制和注解驱动：**

目的：让框架更加易用，帮助开发者最少只用一行代码就能使用框架。

启动机制：封装初始化和启动 RPC 框架的代码，如果不是springboot项目，让消费者和提供者仅用一行代码就可以使用 RPC 框架

注解驱动：如果是 springboot 项目，通过扫描注解的方式，来自动化初始化 RPC 框架的过程。



## 面试题：

#### 什么是RPC框架？它有什么优点？

> 背诵类题目

#### RPC 和 HTTP 有什么区别？RPC 算是计算机网络哪一层的协议？

> 背诵类题目，也可以主观回答

#### 你了解过哪些RPC框架，你的项目和它们相比有什么不同？

> 前面背诵类问题，后面主观回答

#### 请介绍整个系统的核心架构设计，有哪些模块？各模块的作用？各模块之间的关系？

>  主观回答

#### 什么是 Java 的反射机制，你在项目中是如何应用反射的？

> 第一问背诵，第二问主观回答

#### 你在项目中是如何实现消费方调用的？为什么选用 JDK 动态代理和工厂模式？

> 主观回答，部分可背诵

#### 为什么选择了 ConcurrentHashMap 来实现本地服务注册器？它的优势是什么？

> 背诵类题目

#### 你是如何实现项目中的网络通信的？为什么选择了 Vert.x 框架？

> 主观回答，部分背诵

#### 什么是 Hutool 工具库？你在项目中是如何应用 Hutool 工具库提高开发效率的？

> 主观回答

#### 你在项目中使用了哪些设计模式？举例说明你是如何应用的。

> 主观回答

#### 什么是 Mock？你在项目中如何实现服务 Mock 功能？

> 第一问背诵，第二问主观回答

#### 你的 RPC 项目具有哪些配置信息？你是如何读取和管理配置信息的？

> 主观回答

#### 什么是序列化和反序列化？你在项目中是如何处理序列化和反序列化的？

> 第一问背诵，第二问主观回答

#### 你熟悉哪些序列化协议或类库？它们各有哪些优缺点？

> 背诵类题目

#### 我熟悉的序列化有：jdk、json、hessian、kryo、protobuf

jdk是java 原生的序列化方式，不用引入额外的依赖，只需实现 Serializable 接口即可。但缺点就是序列化后可读性差，序列化后数据量大，性能差。

> JSON

优点：

- 可读性好，便于理解和调试

- 支持跨语言

缺点：

- 序列化后数据量大
- 不能很好的处理复杂的数据结构和循环引用

> Hessian

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言，适用于分布式系统中的服务调用

缺点：

- 性能低
- 对象必须实现 Serializable接口，限制了可序列化的对象范围

> Kryo

优点：

- 高性能
- 支持复杂的数据结构和循环引用

缺点：

- 不易读懂和调试
- 不支持跨语言

> Protobuf

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言
- 支持版本化和向前/向后兼容

缺点：

- 不易读懂和调试
- 配置复杂

#### 什么是 Java 的 SPI 机制？你是如何利用 SPI 机制实现模块动态扩展的？

> 第一问可背诵，第二问主观回答

SPI 服务提供接口是Java重要的机制，用来实现模块化开发和插件化扩展。

SPI允许服务提供者使用特定的配置文件来将自己的实现注入到系统中，通过反射机制动态加载实现类对象，而不需要修改原始框架的代码，从而实现了系统的解耦，提高了系统的可扩展性。

一个典型的SPI应用就是JDBC，所有的数据库驱动开发者都可以使用JDBC库，定制自己的数据库驱动程序。

1. 定义一个 Map，用来存储健名和实现类对应的映射关系。
2. 编写 SpiLoader类，实现读取配置，加载实现类的方法。
   1. 用 Map 来存储已加载的配置信息键名和实现类的映射
   2. 通过 Hutool 工具库 ResourceUtil.getResource()方法来扫描指定路径，获取到 键名和实现类的信息，存储到Map中。
   3. 从Map中拿到信息，通过反射获取到实现类对象，并维护一个缓存，下次从缓存中读取，提高效率。

3. 重构序列化工厂，使用 SpiLoader 来加载指定的序列化器。

#### 项目中的服务注册中心有什么作用？是基于什么技术实现的？

> 主观回答

1. 服务提供者可以将自己的服务信息提交到注册中心。
2. 服务消费者从注册中心获取到服务信息列表，从而完成调用。
3. 定期检查服务提供者的健康状态，发现某个服务不可用，就将其从服务列表中去除，从而保证服务消费者能获取到正常的服务提供者。

是基于Etcd技术实现的。

#### 为什么用 Etcd 实现注册中心？该技术有哪些优势和特性？

> 背诵类题目，也可以主观回答

Etcd 是一个 Go 语言实现，开源的，分布式键值存储系统，不要用于分布式系统中的服务发现、配置管理和分布式锁等场景。

特性：

1. 高性能
2. 高可靠，强一致性，使用 Raft 算法来保证数据的一致性。
3. 简单易用，提供了简单的 API
4. 租约机制：用于对键值对设置过期时间，当其过期时，自动将相关的键值对删除。
5. 监听机制：可以监听特定键的变化，变化时可以触发通知。

#### 服务提供者节点主动下线或宕机时，如何保证注册中心上服务信息的有效性？

> 主观回答

我设计了节点下线机制，分为主动下线和被动下线

主动下线：利用 JVM 的 shutdownhook，主动从注册中心移除注册信息。

被动下线：利用 Etcd 的 key 过期机制自动移除。

为了保证正常的服务节点的 key 不会被移除，我设计了心跳检测和续期机制，通过定时任务，定期重新注册该服务节点信息，以达到续期的目的。如果该服务器宕机了，那么就不会续期，过期后会被 Etcd 自动移除。

#### 服务消费者每次都要从注册中心获取服务注册信息么？有没有办法进行优化？

> 主观回答

不需要，因为注册中心的服务信息列表更新频率不高，所以我设计了一个本地缓存列表，第一次从注册中心获取，然后缓存到本地，下次从本地获取。然后利用 Etcd 的监听机制，监听到相应的 key 发生变化时，删除本地缓存对应的 key 就行了。

#### 你的 RPC 框架采用了什么协议？为什么要自定义协议？

> 主观回答

我参考了 Dubbo 的协议设计

1. 自定义了消息结构，设计理念是”用最少的数据传输必要的信息。所以使用了字节数组来拼接消息，消息内容包括消息头和消息体，消息头包括魔数、版本号、序列化、消息类型、状态、请求id和请求体长度信息。
2. 使用 TCP 协议完成网络传输，相比 HTTP 性能更高。

为什么：

1. 更高的性能，减少不必要的数据传输。
2. 更灵活和更好的扩展性，请求头中包含了版本信息，支持向后兼容和协议升级。
3. 更高的安全性，请求头中设置了魔数来进行安全校验。

#### 什么是 TCP 协议的半包粘包问题？你在项目中是如何解决该问题的？

> 第一问背诵，第二问主观回答

当客户端像服务端连续多次发送消息时，半包是指服务端收到的消息比客户端单次发送的消息数据少，粘包是指服务端收到的消息比客户端单次发送的消息数据多。

我使用了 Vert.x 框架中内置的 RecordParser 来解决，RecordParser 可以保证下次读取到固定长度的字符，但是消息体的长度是不固定的，所以通过调整 RecordParser 的长度来解决。

将完整的消息读取拆分为两次

1. 第一次只读取消息头，因为长度固定，所以可以保证完整读取。
2. 第二次读取消息体，根据消息头中的消息体长度信息来改变 RecordParser 的固定长度，保证读取到完整的消息体。

#### 为什么要使用负载均衡？有哪些负载均衡算法？项目中的负载均衡器模块是如何实现的？

> 前面背诵类题目，后面主观回答



#### 项目中的负载均衡器模块是如何实现的？

> 主观回答

我在项目中实现了多种负载均衡算法，包括轮询、随机和一致性 Hash。



#### 什么是一致性 Hash 算法？相比普通的轮询算法有什么优势？

> 背诵类题目

#### 为什么要使用重试机制？有哪些重试策略？项目中的重试机制是如何实现的？

> 前面背诵类题目，后面主观回答

#### 为什么要使用容错机制？有哪些容错策略？项目中的容错机制是如何实现的？

> 前面背诵类题目，后面主观回答

#### 如何简化开发者使用 RPC 框架的成本？怎么通过注解驱动框架的启动？

> 主观回答

#### 在开发过程中，你遇到过比较复杂的技术问题或挑战吗？如果有，请谈谈你是如何解决这些问题的？

> 主观回答，以下仅为一种可行的示例答案



## 伙伴匹配项目介绍



## 伙伴匹配模块介绍



## 面试题

#### 请介绍一下你在项目中使用的Redis，它有哪些优势，为什么选择使用Redis实现分布式Session？

#### 你在用户登录功能中提到使用Hash代替String存储用户信息，这样的做法有什么好处？在实际应用中，Hash与String存储方式有哪些区别？
#### 请解释一下Java8StreamAPI和Lambda表达式的作用，以及在项目中如何应用它们来简化集合处理？

#### 你提到使用EasyExcel进行批量导入数据库，能否介绍一下EasyExcel的使用方法和优势？

#### 你是如何自定义线程池的？如何合理设置线程池的参数？

#### 你是如何测试批量导入数据库的性能的？用了哪些工具或方法

#### 你在使用Redis缓存高频访问用户信息时提到了自定义序列化器，为什么需要自定义序列化器，以及自定义序列化器的实现方式？
#### 你在项目中是如何实现Redis缓存的？选用了哪种Redis数据结构？

#### 使用Redis缓存时，有哪些可能出现的常见问题？你又是如何解决的？

#### 在解决首页加载过慢的问题中，你使用了SpringScheduler定时任务和分布式锁，请解释一下定时任务的执行原理和此处分布式锁的作用。

#### 尔在项目中使用Redisson分布式锁解决了接口幕等性的问题，请简要介绍一下Redisson分布式锁的使用场景和实现原理。
#### 你提到使用优先队列来减少TOPN运算过程中的内存占用，能否解释一下优先队列的特点和在项目中的具体应用

#### 在项目中，你自主编写了Dockerfile来实现自动化镜像构建及容器部署，请介绍一下用Docker的优势？

#### 你在项目中使用Knife4j和Swagger自动生成后端接口文档，请解释一下Swagger的作用，以及在项目中使用Swagger的好处。

## 真实面经

#### 看到我伙伴匹配项目上写到通过使用redis缓存减小接口响应的时长，怎么接口响应时长，是怎么做的？

#### 如何优化数据库逻辑以减少数据库查询的时间？ 面试官建议我学一下elasticSearch

#### 如何解决redis中的数据和数据库中的数据不一致？

#### 讲一下什么是线程安全？线程池参数有哪些？

#### 如何解决多线程环境下线程安全问题？

#### 学习过消息队列吗？ 什么时候能用到消息队列？



#### 使用redis缓存后响应时长是怎么测试的？

#### 为什么降低了这么多？

#### 如何使用redis实现redis缓存的？

#### 缓存预热是怎么实现的？

#### 解释一下什么是线程安全？

#### redis如何实现分布式锁的？



#### 优先队列：

优先队列是根据优先级来实现出队入队的。

项目中，维护一个优先队列，保持 N 个，比优先队列内优先级低的不选择入队，比优先队列优先级大的，实现入队，并淘汰一个低的，使得队列保持在 N 中，减少内存的使用，Java的优先队列使用 PriorityQueue



具体的实现思路：

1. 创建大顶堆的优先队列。
2. 通过传入比较器创建，泛型是Pair(Pair 是存储键值对的，第一个键是user，第二个是相识度的分数)，
3. 先查询数据库中的所有用户
4. 优先队列初始化，将前 num(这个值是前端传递过来的，默认为5) 个用户数量插入队列中。
5. 计算相识度
6. 将之后的用户与登录用户逐一相比较计算分数，比较堆顶的距离与计算的分数，若计算分数要小于，则删除堆顶元素，插入新元素到优先队列中。
7. 通过Stream 流将优先队列中存储的userid 获取出来，收集为UserIdList。
8. 根据 UserIdList 查询出最终的用户列表，进行脱敏返回。

#### Redis GEO实现查询附近的人：

我提供两个接口。1.上传地理位置，2.查询附近的人。**查询附近的人之前必须先上传地理位置**

1. 先封装一个请求类：包含userId，经度lon，纬度lat，半径redius，两个接口的请求参数都是使用这个类
2. 封装常量类，用来定义上传Redis的key值

#### 线程池批量导入数据：

项目中，我使用 ThreadPoolExecutor 来实现线程池，创建任务列表，在循环中创建单一任务，加入到任务列表中。循环外使用线程池异步，并发的执行任务列表

遇到了哪些难点：

1. 腾讯云实现头像
2. 编辑距离算法
3. 定时任务+Redisson分布式锁

具体的球友按照自身实际情况

#### 用户登录问题：分布式除了使用Redis实现 ，还有哪些实现方式

Session 复制：利用 Tomcat 等 Web 容器同步复制

Session 前端存储：利用用户浏览器中 Cookie 保存 Session 信息

Session 粘滞方案：利用 Nginx 可以做四层 Hash 或七层 Hash 的特性，保证用户的请求都落在同一台机器上

Session 后端集中存储方案：利用 Redis 集中存储 Session，Web 应用重启或扩容，Session 也无需丢失。

上面四种方案，优先推荐第四种。

当然第四种方案需要一定的开发工作量，前期还没改造的过程可以选择 第三种方案中间过渡。