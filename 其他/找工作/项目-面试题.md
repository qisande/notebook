# 简快接口平台

#### 1. 为什么要做这个项目？



#### 2. 介绍一下这个项目



#### 3. 这个项目里有哪些模块，每个都有什么作用，相互之间是怎么联系的？



#### 4. 你负责哪些工作？



#### 5. 对你来说，有哪些比较难的技术点，你是怎么解决的？







三张表：用户表、接口表、用户接口关系表

两条线：

第一：管理员

用户的增删改查（注册（分配ak、sk）、登录（利用 redis 来存储登录态）、注销）

管理员对接口信息进行增删改查（发布接口、上线接口、下线接口、删除接口、调用接口，统计调用次数前三的接口）

用户接口关系增删改查（开通接口、查看接口、调用接口）

第二：用户

用户通过 SDK 直接调用方法，通过 Hutool 工具包向网关发送 HTTP 请求，获得结果后返回给用户。根据请求内容生成签名，并在请求头中添加签名。

网关拦截请求后，第一打印日志；第二，通过签名来鉴权；第三，路由到真正的接口地址上；第四，调用接口后，更新接口调用次数。第五，返回结果给用户。

网关通过 dubbo 调用后台管理的方法（获取接口信息、调用次数加一、获取开通接口的用户信息）



技术点：

API 签名认证

SDK 开发

Spring Cloud Gateway 的使用

Dubbo RPC 框架的使用



## 面试题：

#### 你的项目中使用了哪些技术栈？请分别介绍一下 SpringBoot、Dubbo、Gateway 在项目中的作用

SSM + Spring Boot + Spring Cloud Gateway + Dubbo + Nacos + Redis + Mybatis Plus + Hutool 工具库。

SpringBoot：用于快速构建项目，并整合依赖。

Dubbo：RPC 框架，实现项目中不同模块的高性能调用。

Gateway：API 网关，执行统一的安全认证、请求转发、请求日志、公共业务等。

#### 你将后端项自划分为了多个子项目，请分别介绍这几个子项目的作用、以及它们之间是如何协作和交互的？

src：负责用户和接口管理。

gateway：主要负责集中的路由转发和业务处理。

common：包含其他模块中需要用到的方法、工具类、实体类等。

client-sdk：封装了对各个 API 接口的调用方法。

interface：提供模拟的 API 接口。

交互流程：首先管理员创建接口后通过 backend 保存到数据库中。用户在自己的项目中引入 SDK 模块，并通过方法调用 API 接口。然后请求被发送到 API 网关，进行用户鉴权和接口调用统计，最后将请求转发到实际的 API 接口。

#### 请简要介绍 Maven 的基本概念、作用以及如何使用 Maven 进行多模块依赖管理和打包？

Maven 是一个开源的构建工具，用于项目的构建和依赖管理。

每个模块都有自己的 pom.xml 文件，通过这个文件可以引入依赖。对于 common  和 client-sdk 模块，可以使用 install 命令安装依赖到本地，然后在其他项目中引入依赖。

#### 请介绍一下你是如何使用 MyBatisPlus 框架的 QueryWrapper 实现了对 MySQL 的灵活查询？

通过 QueryWrapper 可以构造查询条件，比如使用 like 指定模糊查询条件，使用 orderby 指定排序条件等

#### 什么是 OpenAPI 规范？它有什么作用或好处？

OpenAPI 是一种用于定义和描述 API 的开放标准，比如用 JSON 来描述 API 的参数。

#### 你在项目中使用了 Swagger + Knife4j 自动生成接口文档，请谈谈 Swagger 和 Knife4j 的作用和它们对项目开发的影响

Swagger 是一个用于自动构建和生成接口文档的工具集，可以根据 controller 层的代码自动生成文档，并且可以在线调试。Knife4j 是 Swagger 的增强版，可以生成更加美观的接口文档，还有接口分组排序等增强功能。

#### 什么是 API 签名认证算法？它有什么作用？你又是如何实现它的？

是一个用于验证 API 请求的合法性和完整性的安全机制。可以增强 API 的安全性。

1. 给每个用户生成一个唯一的密钥对，并保存到数据库中。
2. 请求发使用 secretKey 对请求参数和数据进行签名。
3. 请求方将请求签名、请求参数和用户标识发送个 API 提供者。
4. 提供者根据用户标识去数据库中查找 accessKey 和 secretKey，并使用相同的签名算法生成签名，和请求中的签名进行比对，如果一致则可以信任请求方。

#### 你在项目中使用了 SpringCloudGateway 作为API网关，请解释一下 API 网关的应用场景，以及它在项目中的实际应用？

路由转发、鉴权、负载均衡、访问控制、流量染色等

1. 统一鉴权：使用 API 签名认证算法来保证请求的合法性。
2. 公共业务逻辑：对每个接口的调用进行调用次数的统计。
3. 路由转发：前端发送请求到 API 网关，通过网关转发请求到实际的 API 接口。
4. 流量染色：给请求加上特定的请求参数，以便确定 API 的来源和合法性。

#### 你是如何基于 SpringBootStarter 开发了客户端 SDK 的，讲述一下实现过程？

1. 明确 SDK 的功能。
2. 引入相关依赖。
3. 编写配置类，加上特定注解，实现自动从配置文件中读取配置。
4. 开发业务逻辑
5. 使用 install 命令打包 SDK。
6. 在其他本地项目中引入 SDK。

#### 用户如何使用你开发的客户端 SDK？讲述一下流程

1. 在平台上进行注册登录，获取到开发者密钥。
2. 下载 SDK 代码到本地，或者从 Maven 中央仓库中引入依赖。
3. 在项目的配置文件中填写客户端配置，比如 ak 和 sk。
4. 在需要的地方进行依赖注入得到客户端并使用。

#### 有哪些客户端 SDK 的设计技巧？

可以从易用性、可理解性、可扩展性和稳定性等几个角度出发，尽可能的提升开发者的调用体验。

#### 什么是 RPC？为什么要使用 DubboRPC 框架它有什么优势？

是一种实现分布式系统通信的协议和技术，允许一个服务器程序调用另一个服务器程序的方法。

Dubbo 框架的优势就是性能高、协议多、功能强、生态好、易扩展等。

#### 你在项目中是如何使用 DubboRPC 框架的，讲述一下使用流程？

阅读官方文档，完成 demo 的基础 RPC 调用。

启动 Nacos 注册中心，编写 Nacos 的连接配置，通过注解开启 Dubbo 支持。优先启动服务提供者项目，再启动服务调用者项目。

#### 你在公共模块中抽象了模型层和业务层代码，请解释一下模型层和业务层的概念，并说明抽象公共模块的目的和好处

模型层包括数据模型、实体类、业务封装模型等

业务层包括业务逻辑和处理规则。

目的是为了复用代码，好处就是便于项目的维护和理解。

#### 你通过 API 网关实现了流量染色技术，请介绍一下流量染色的概念、以及它的作用？

有三个关键概念

1. 请求分类
   - 将请求分为不同的类别和组。
2. 请求标记
   - 请求被标记为属于特定的类别或组。
3. 处理策略
   - 为每个请求类别定义特别的处理策略。

本项目中通过给请求加上特定的请求头参数， 便于让下游的 API 服务确定请求的来源和合法性。



## 真实面经

#### 介绍一下api项目和伙伴匹配项目

#### 项目的人员分工以及项目需求的分工是如何划分的？

#### 然后的话您的接口调用大概有多少的QPS？

#### 13.19. 你在里面负责什么内容？你觉得你负责的模块里面最难的是哪一部分？

#### 13.15. 整个这个项目的过程中，就是你觉得对你来说挑战比较大的一个事情是什么？

比如在设计实现 API 签名认证算法时，发现鉴权结果和预期不同 —— ak、sk 明明完全一致，但就是无法通过鉴权。然后你通过 debug 的方式，定位到了关键问题是由于中文编码、或者字段大小写不一致导致了签名不同。最后你通过修改中文编码等方式确保客户端和服务端生成的签名一致进行解决。

#### 13.32. 可以简单介绍一下第一个项目的应用场景？

这主要是对于开一个软件开发的一个开发者来进行使用的。当然你用户的话，你也可以在线对一个对一些接口一些在线的一个调用。

主要对开发者来说的话，他可以对一些在这个平台上线的一些接口对进行一些。比如你有些功能需要一些接口，需要一些三方接口来实现。你可以在这个平台上来进行一些寻找。它会比如有一些你需要前端需要调用一个当日的每日的天气。在这个平台上你可以根据提供一个文档，在项目在自己的项目中进行一个接入。同时的话他也提供了一个SDK的一个工具包。本地的一个SDK你可以用开发者可以下载到本地，对这个项目进行一个整合到自己的项目中，大致是这样一个作用。

#### 13.33. 你这个项目相当于是整合了第三方的接口然后进行SDK的一个开发吗？

也可以三方来接入自己，也可以上线一些自己的原创的一些接口。相当于是一个平就是一个也可以理解为你那种对所有的接口进行一个聚合，包括三方的以及自己的一些接口。

#### 13.34. 本项目中你用到了Dubbo，请问在项目中起到了什么作用呢？

这个项目因为是分模块的，它在引入double它一个远程调用，对不同模块之间的一些接口进行一个远程的调用。可以个人开发者的话不用关心不同模块之间的一些远程的调用的传输协议，把它当成像本地方法一样实现不同模块间的调用。

#### 13.36. 那你先说一下在这个项目上面有没有让你觉得有挑战的地方？

因为这个项目我觉得学到更多的可能在AK和SK设计的那些那那一块。

你正常来说你我这个接口正常来说每个人调用的话，我不可能免费给你调用。一般来说是需要收费的。然后涉及到收费的话，你要就要采就要去就要防止一些用恶意用户来进行一个访问。这个时候我对每一个在我这个平台上注册的用户，我先注册，注册的时候已经给他生成一个默认，生成一个随机，生成一个AK和SK然后存到你的数据库里面。然后你如果要来访问我的数据库的时候，你要来访请求我这个接口的话，我会把请你把你的AK和一些请求头以及时间戳，或者加一些随机数，通过前通过这个请求头来进行一个加密算法。然后我们当时选的是MD5加密的。

加密完之后，如果因为我们是通过一个网关请求，请求都会统一进入到网关层。在网关层的话，它会通过你用户的ID然后查询到你这个数据库里面的AK通过AK然后再根据获得请求，请求头里面获取到那个随机数，以及你的请求的一个数据以及随机数，然后再进行一个MD5加密。

MD5加密后的一个数据，如果相等的时候，你我这个API接口这个提供者才能信任你这个调对我这个接口调用的对他产生了信任，这时候才能进行调用，否则的话他就不允许他调用。这时候可以防止有一些用户，有一些恶意用户，比如获取到你这个伪造一个请求，然后来恶意的攻击我这个API。

你这个AK跟SK跟oauto的认证是同一套体系吗？

类似。因为我们当时参考的是腾讯云以及一些阿里云。他当时你如果想要使他第三方平台一些OSOSS那种对象存储的话，他会给你提供一个AK和SK。我们当时是通过这来思考的那我在登录的时候，

#### 13.37. 你们主要是在上面发布了哪些接口呢？

发布结果的话，我们有一些比如在线调试调在线桥每日的天气，以及根据一些就比如给一个相关的一个字段，然后返回你一个想要的一个图片吧。还有一些我们在别的一些我们当时写的别的项目，我们觉得可能后期会用到，然后就把这些封装到项上线到项目当中，然后可以对他进行后期一个项目开发进行一个复用。

#### 13.38. 就是你这边统计接口的调用次数是怎么统计的？

因为我们当时想的是有3种，因为正常来说你前我你前端如果要访问我这个项目的话，有一种情况是你前端可以直接访问我这个模拟的这个接口。然后还有一种是通过后端，你前端先到后端，然后再通过后端来访问这个模拟接口。这种情况的话可以用一些NGINX这种来进行一个负载均衡。

但是我们考虑到NGX可能编程的话更复杂一些。我们这时候用的是SpringBoot gataway, 然后你前端先通先访问接口的话，都会通过先会请求到API网关层。网关层在网关中统一对一个次数进行一个计算。你到这个接口的时候，你先对你要请求哪一个接口，然后对这个进行计算之后，通过网关层来通过网关层来对你这个路由统一进行转发。转发到你对应的有一个接口，有一个模拟接口的一个模块。通过这个模拟接口的模块就可以进行真实的一个对接口的请求，直接就在网关层进行数据统进行这个次数的统计。

#### 13.39. 涉及了API的签名认证的一个算法，给用户分配分分配了独立的那个AK用于健全，对吧？对，那那我想问一下你这个里面的话有没有防篡改相关的假设？

一般我们这个API签名认证算法的话，正常流程是你你你在注册的时候有生成这个AK和SK。你如果请求API的话，你会把这个AKAK1请求后等参数传过去。一般AK和SK是不可以被第三方获得的。你只传的时候只会传一个AK然后以及请求头以及时间戳还加了一个随机数，然后通过网关层来进行一个统一的拦截，然后进行健全。健全之后根据这个把根据请这个请求头这个加密的里面的获取到AK然后通过这个AK来查询它数据库里面真实的一个AK和SK，然后再进行一个MD5加密，然后两个对比之后才能如果相同的话，才能对这个请求者进行一个信任。如果中间人对他进行一个篡改的话，用用户如果觉得他这个用户如果觉得他这个请求的有一些异常的话，他他会申请对这个AK和SK进行一个重新生成。

对于数据的篡改并没有进行开发

#### 13.40. 您在设计这个签名认证算法的时候，有没有参考过一些业界的一些认证。

比如说类似于一下阿里云或者腾讯云。

因为阿里云跟腾讯云，如果因为当时我们如果存储图片的话，当时是刚开始考虑的是腾讯云，阿里云的对象存储。他是给你提供一个你想要使用的话，他给你提供一个AK和SK。你可以在本地进行一个进行一个配置，然后再在yml文件里面进行一个配置。配置完之后，你就可以对图片进行上传以及下载了。当时是可当时是根据他这方面来进行一个实现的。

#### 13.41. 您说解决多个子系统代码重复的问题，您抽象出了一些公共模块。那您具体抽象了哪些公共模块？然后抽象的一个原则是什么样子的？中间有没有用到什么样的一些设计模式？

因为我们这个公共模块层，它其实是包含了一些，就比如说各个模块有可能很多模块都需要使用到的一些实体类，还有一些公共场公共每个模块都要涉及到一些，就比如有一些方法类，或者就有一些封装的一些youtube那种封装的一些包，这些是在公共模块的。因为公共模块里面涉及的东西不是太多。当时分开的模块是主要是为了能够在因为我们当时的公共模块的话，如果要引用的话，是把它通过maven进行打包，然后在需要的模块里面进行引用就可以使用了当因为也模公共模块里面涉及到的东西也不是很多，也没有依据那个设计模式来划分。





# Q-RPC 框架

RPC 是一种计算机通信协议，允许一个程序像调用自己的方法一样，调用另一个程序的接口，而不需要了解数据的传输处理过程、底层通信细节。

消费者想要调用提供者，需要提供者启动一个 web 服务，然后通过请求客户端发送 HTTP 请求或者其他协议的请求来调用。RPC 就是提供一个统一的服务调用接口，通过请求处理器根据客户端的请求参数来进行不同的处理、调用不同的服务和方法。

具体实现就是服务提供者维护一个本地服务注册器，记录服务和实现类的映射。然后请求处理器请求参数中的服务名从服务注册器中找到对应的服务实现类，并通过 Java 反射机制调用请求参数中的方法名指定的方法。

具体模块：

**全局配置加载**：

目的：

配置信息太多需要进行统一管理。通过编写配置文件来自定义配置，同时维护一个全局配置对象，便于快速获取到配置。

具体实现：

1. 读取配置文件：编写工具类，通过 Hutool 的 Setting 模块，直接读取指定名称的配置文件，并转化为 Java 对象。

2. 维护全局配置对象：在 RPC 项目启动的时候，使用双检锁单例模式创建配置对象实例，集中的从这个对象中获取配置信息，避免重复创建对象，减少性能开销。

**序列化器和 SPI 机制**：

目的：

Java 对象存活在 JVM 虚拟机中，如果想在网络中进行传输，就需要序列化和反序列化。同时能够让框架的开发者定制序列化器、指定序列化器。

具体实现：

首先是不同序列化器的具体实现，其次使用自定义的 SPI 机制，支持用户自定义序列化器并指定键名。

使用 Hutool 工具包的 ResourceUtil 读取资源文件，将实现类保存到 HashMap 中。创建序列化器工厂，当需要实例的时候，使用反射机制获取到实现类的对象。

**注册中心实现**：

目的：

帮助服务消费者获取到服务提供者的调用地址，而不是将地址硬编码到项目中。

具体实现：

注册中心使用 Etcd，并实现初始化、服务注册、服务注销、服务发现、服务销毁等方法。可以利用 SPI 机制自定义或指定不同的注册中心。服务消费者使用代理并调用服务发现方法从注册中心获取到服务提供者的地址，之后可以根据地址发送请求，并拿到响应后的数据。

通过续期机制来实现心跳检测，保证及时更新注册中心，剔除下线节点。

消费端增加本地缓存。在进行服务发现时，拿到服务信息后缓存到本地，并且优先从缓存获取服务。同时监听 key 的变化，当注册中心清理缓存后，本地也及时清理缓存，保证数据一致性。

**自定义协议**：

目的：

HTTP 协议的头部信息和格式较为冗余，影响网络传输性能。需要自定义消息结构和网络传输。

具体实现：

网络传输选择 TCP 协议，消息结构包括请求头和请求体，请求头包括魔数（安全性保证）、版本号、序列化器、消息类型、状态、请求 id、消息体长度。

发送请求前使用编码器将消息对象转换为 Buffer，接收消息后使用解码器将 Buffer 转换为消息对象。

请求发送：

服务消费者通过服务代理发送请求。

第一，构造请求；第二，从注册中心获取请求地址；第三，构造消息对象；第四，编码消息对象；第五，发送 TCP 请求；第六，接受响应；然后解码为消息对象。

请求处理器：

服务提供者通过请求处理器接受请求并调用服务。

第一，接受请求并解码为消息对象；第二，通过反射调用服务实现类；第三，封装响应结果；第四，构造消息对象；第五，编码；第六，发送响应。

**负载均衡**：

目的：

减轻单个节点的压力，利用好其他节点的资源。确保每个资源都能有效的处理负载，增加系统的并发量。

具体实现：

有轮巡、随机、一致性 Hash 等算法来实现负载均衡。

使用服务器地址来计算 Hash 值，并引入虚拟节点，将服务器节点均匀的分散到整个 Hash 环上。

**重试机制**：

目的：

在调用接口失败后，使得服务消费者拥有自动重试的能力，提高系统的可用性。

具体实现：

引入 Guava-Retrying 库，使用 Guava-Retrying 提供的 RetryerBuilder 来指定重试条件、重试等待策略、重试停止策略等。比如当发现异常时重试，固定 3s 重试一次，超过 3 次后停止重试。

**容错机制**：

目的：

消除偶发、单点故障对系统带来的整体影响。

具体实现：

容错有多种方式，比如降级、熔断、限流、快速失败、静默处理等，可以先重试后容错。在重试多次抛出异常时，获取容错策略并执行，比如静默处理。

**启动机制**：

目的：

让框架更易用，帮助开发者最少只用一行代码，就能轻松使用框架。

具体实现：

服务提供者利用 @RpcService 注解，并实现 BeanPostProcessor 中的方法，将服务注册到本地和注册中心。

服务消费者利用 @RpcReference 注解，并实现 BeanPostProcessor 中的方法，先生成代理对象并注入到属性中。





**全局配置：**

目的：将配置与代码解耦，方便用户定制化开发

在rpc项目启动时，获取到全局配置对象，利用Hutool工具包读取配置文件并生成配置对象，其中使用到了**双检锁单例模式**和懒加载机制。

好处？

这样的好处就是，可以集中管理配置，并减少对象创建。

为什么要用双检锁单例模式？

双检锁是为了保证操作的原子性，保证同一时间只能有一个线程来执行这个操作

什么是懒加载？

需要的时候才创建对象，避免浪费

**接口 Mock：**

目的：有的接口没开发完成，利用代理对象返回假的数据，利于调试，测试，可以快速打通整个开发流程。

**SPI机制：**

目的：实现模块化开发和插件化扩展

SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过反射机制动态加载这些实现，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。

一个典型的SPI应用场景是 JDBC （Java数据库连接库） ，不同的数据库驱动程序开发者可以使用JDBC库，然后定制自己的数据库驱动程序。

**序列化：**

目的：Java 对象不便于在网络传输，所以需要将 Java 对象转化为字节流。

有几种主流的序列化方式，分别是：

json、hessian、kryo、protobuf，这几种方式个有优劣，背一下，因为 json 的易读性好，便于理解和调试，且跨语言支持广泛，所有作为默认的序列化方式

**注册中心：**

目的：帮助消费者获取到服务提供者的地址，将 url 与代码解藕

提供者注册地址等信息到注册中心，消费者从注册中心获取信息，得到地址，通过地址对提供者发起调用

注册中心实现用的是 Etcd

提供者：主要功能是服务注册和心跳检测

服务注册就是将节点信息注册到注册中心

心跳检测是为了检验目标系统的状态，如果系统故障或不可用，从而出发相应的处理或告警机制

实现：用到了 Etcd 的续期机制，给 key 设置过期时间让节点定期续期，到时间没续期就知道服务挂了，将节点信息放到本地集合中，定期扫描集合重新注册。

消费者：主要功能是服务发现，本地缓存，监听机制

服务发现就是从注册中心拿到节点信息，从而去调用服务。将节点信息放到本地 Map 中缓存起来，方面下次使用。

监听机制：当节点信息变化了，需要去更新本地缓存，用到了 Etcd 的监听机制，监听到 key 发生变化时通知消费者。

**自定义协议：**

目的：HTTP 是一个更通用的协议，比较臃肿，而 RPC 模块是定制的，可以自定义更精简的请求头和响应头，减小体积，提高传输效率。

网络传输：采用 TCP 协议，更底层 （传输层）效率高

消息结构：用最少的空间传递必要的信息。

请求头：参考了 Dubbo 的协议设计。请求 id，请求体长度。

另外还需要编码器和解码器

编码器：创建缓冲区对象，将字节数组按顺序依次写入缓冲区

解码器：从缓冲区按顺序依次将字节数组读取

半包和粘包问题：

半包：每次收到的数据更少了

粘包：每次收到的数据更多了

半包解决：在请求头中设置请求体的长度，判断长度是否符合预期，不完整就留到下次再读取

粘包解决：只读取指定长度的数据，超过的留到下次读取

利用 Vert.x 的 RecordParser 来解决，为 Parser 指定读取固定长度的内容，如果请求体每次长度固定，则可以解决。

但是长度是变得，所有调整 RecordParser 读取时的长度，可以分两次来读取

1. 先读取请求头，长度固定，可以完整读取
2. 再读取请求体，根据请求体的长度信息，来设置 RecordParser 读取时的长度

**负载均衡：**

目的：如果有多个服务节点，利用负载均衡可以减轻单个节点的压力，使服务请求比较均匀的分布到各个节点上，增加系统的并发量

轮训：按照循环顺序将请求发配给每个服务器，适用于各服务器性能相近的情况

随机：随机选择一个服务器来处理请求，适用于各服务器性能相近且负载均衡的情况

一致性 Hash：每个节点或服务器，在环状结构上占据一个位置，将请求的哈希值映射到环上一个点，顺时针寻找第一个大于等于其值的点，路由到该节点上。为了使节点在环上更加均匀的分布，可以创建虚拟节点。

计算请求的方法名的 Hash 值，调用一致性 Hash 算法，根据 Hash 值，找到对应的节点，所以方法名相同总会请求到相同的节点上。

**重试机制：**

目的：有时可能会调用接口失败，为了提高系统的可用性，可以进行重试。

重试策略实现：固定重试间隔

使用 Gvava-Retrying 提供的 RetryBuilder 可以很方便的指定重试条件、重试等待策略、重试停止策略、重试工作等。

比如：发生异常时重试，等待 3s，重试 3次后停止，每重试一次还可以执行额外的任务。

**容错机制：**

目的：提高系统的可靠性和健壮性，比如重试一定次数后仍然失败，接下来由容错机制来处理。

重试机制也可以看成容错机制的一种，可以将各种策略来组合使用，比如：

1. 系统调用服务 1 实现网络错误，使用重试。
2. 重试几次失败后，使用降级，改为调用不依赖网络的服务2，完成操作。

1. 快速失败：直接抛出异常
2. 静默处理：直接返回响应

**启动机制和注解驱动：**

目的：让框架更加易用，帮助开发者最少只用一行代码就能使用框架。

启动机制：封装初始化和启动 RPC 框架的代码，如果不是springboot项目，让消费者和提供者仅用一行代码就可以使用 RPC 框架

注解驱动：如果是 springboot 项目，通过扫描注解的方式，来自动化初始化 RPC 框架的过程。



## 面试题：

#### 什么是RPC框架？它有什么优点？

> 背诵类题目

#### RPC 和 HTTP 有什么区别？RPC 算是计算机网络哪一层的协议？

> 背诵类题目，也可以主观回答

#### 你了解过哪些RPC框架，你的项目和它们相比有什么不同？

> 前面背诵类问题，后面主观回答

#### 请介绍整个系统的核心架构设计，有哪些模块？各模块的作用？各模块之间的关系？

>  主观回答

#### 什么是 Java 的反射机制，你在项目中是如何应用反射的？

> 第一问背诵，第二问主观回答

#### 你在项目中是如何实现消费方调用的？为什么选用 JDK 动态代理和工厂模式？

> 主观回答，部分可背诵

#### 为什么选择了 ConcurrentHashMap 来实现本地服务注册器？它的优势是什么？

> 背诵类题目

#### 你是如何实现项目中的网络通信的？为什么选择了 Vert.x 框架？

> 主观回答，部分背诵

#### 什么是 Hutool 工具库？你在项目中是如何应用 Hutool 工具库提高开发效率的？

> 主观回答

#### 你在项目中使用了哪些设计模式？举例说明你是如何应用的。

> 主观回答

#### 什么是 Mock？你在项目中如何实现服务 Mock 功能？

> 第一问背诵，第二问主观回答

#### 你的 RPC 项目具有哪些配置信息？你是如何读取和管理配置信息的？

> 主观回答

#### 什么是序列化和反序列化？你在项目中是如何处理序列化和反序列化的？

> 第一问背诵，第二问主观回答

#### 你熟悉哪些序列化协议或类库？它们各有哪些优缺点？

> 背诵类题目

#### 我熟悉的序列化有：jdk、json、hessian、kryo、protobuf

jdk是java 原生的序列化方式，不用引入额外的依赖，只需实现 Serializable 接口即可。但缺点就是序列化后可读性差，序列化后数据量大，性能差。

> JSON

优点：

- 可读性好，便于理解和调试

- 支持跨语言

缺点：

- 序列化后数据量大
- 不能很好的处理复杂的数据结构和循环引用

> Hessian

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言，适用于分布式系统中的服务调用

缺点：

- 性能低
- 对象必须实现 Serializable接口，限制了可序列化的对象范围

> Kryo

优点：

- 高性能
- 支持复杂的数据结构和循环引用

缺点：

- 不易读懂和调试
- 不支持跨语言

> Protobuf

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言
- 支持版本化和向前/向后兼容

缺点：

- 不易读懂和调试
- 配置复杂

#### 什么是 Java 的 SPI 机制？你是如何利用 SPI 机制实现模块动态扩展的？

> 第一问可背诵，第二问主观回答

SPI 服务提供接口是Java重要的机制，用来实现模块化开发和插件化扩展。

SPI允许服务提供者使用特定的配置文件来将自己的实现注入到系统中，通过反射机制动态加载实现类对象，而不需要修改原始框架的代码，从而实现了系统的解耦，提高了系统的可扩展性。

一个典型的SPI应用就是JDBC，所有的数据库驱动开发者都可以使用JDBC库，定制自己的数据库驱动程序。

1. 定义一个 Map，用来存储健名和实现类对应的映射关系。
2. 编写 SpiLoader类，实现读取配置，加载实现类的方法。
   1. 用 Map 来存储已加载的配置信息键名和实现类的映射
   2. 通过 Hutool 工具库 ResourceUtil.getResource()方法来扫描指定路径，获取到 键名和实现类的信息，存储到Map中。
   3. 从Map中拿到信息，通过反射获取到实现类对象，并维护一个缓存，下次从缓存中读取，提高效率。

3. 重构序列化工厂，使用 SpiLoader 来加载指定的序列化器。

#### 项目中的服务注册中心有什么作用？是基于什么技术实现的？

> 主观回答

1. 服务提供者可以将自己的服务信息提交到注册中心。
2. 服务消费者从注册中心获取到服务信息列表，从而完成调用。
3. 定期检查服务提供者的健康状态，发现某个服务不可用，就将其从服务列表中去除，从而保证服务消费者能获取到正常的服务提供者。

是基于Etcd技术实现的。

#### 为什么用 Etcd 实现注册中心？该技术有哪些优势和特性？

> 背诵类题目，也可以主观回答

Etcd 是一个 Go 语言实现，开源的，分布式键值存储系统，不要用于分布式系统中的服务发现、配置管理和分布式锁等场景。

特性：

1. 高性能
2. 高可靠，强一致性，使用 Raft 算法来保证数据的一致性。
3. 简单易用，提供了简单的 API
4. 租约机制：用于对键值对设置过期时间，当其过期时，自动将相关的键值对删除。
5. 监听机制：可以监听特定键的变化，变化时可以触发通知。

#### 服务提供者节点主动下线或宕机时，如何保证注册中心上服务信息的有效性？

> 主观回答

我设计了节点下线机制，分为主动下线和被动下线

主动下线：利用 JVM 的 shutdownhook，主动从注册中心移除注册信息。

被动下线：利用 Etcd 的 key 过期机制自动移除。

为了保证正常的服务节点的 key 不会被移除，我设计了心跳检测和续期机制，通过定时任务，定期重新注册该服务节点信息，以达到续期的目的。如果该服务器宕机了，那么就不会续期，过期后会被 Etcd 自动移除。

#### 服务消费者每次都要从注册中心获取服务注册信息么？有没有办法进行优化？

> 主观回答

不需要，因为注册中心的服务信息列表更新频率不高，所以我设计了一个本地缓存列表，第一次从注册中心获取，然后缓存到本地，下次从本地获取。然后利用 Etcd 的监听机制，监听到相应的 key 发生变化时，删除本地缓存对应的 key 就行了。

#### 你的 RPC 框架采用了什么协议？为什么要自定义协议？

> 主观回答

我参考了 Dubbo 的协议设计

1. 自定义了消息结构，设计理念是”用最少的数据传输必要的信息。所以使用了字节数组来拼接消息，消息内容包括消息头和消息体，消息头包括魔数、版本号、序列化、消息类型、状态、请求id和请求体长度信息。
2. 使用 TCP 协议完成网络传输，相比 HTTP 性能更高。

为什么：

1. 更高的性能，减少不必要的数据传输。
2. 更灵活和更好的扩展性，请求头中包含了版本信息，支持向后兼容和协议升级。
3. 更高的安全性，请求头中设置了魔数来进行安全校验。

#### 什么是 TCP 协议的半包粘包问题？你在项目中是如何解决该问题的？

> 第一问背诵，第二问主观回答

当客户端像服务端连续多次发送消息时，半包是指服务端收到的消息比客户端单次发送的消息数据少，粘包是指服务端收到的消息比客户端单次发送的消息数据多。

我使用了 Vert.x 框架中内置的 RecordParser 来解决，RecordParser 可以保证下次读取到固定长度的字符，但是消息体的长度是不固定的，所以通过调整 RecordParser 的长度来解决。

将完整的消息读取拆分为两次

1. 第一次只读取消息头，因为长度固定，所以可以保证完整读取。
2. 第二次读取消息体，根据消息头中的消息体长度信息来改变 RecordParser 的固定长度，保证读取到完整的消息体。

#### 为什么要使用负载均衡？有哪些负载均衡算法？项目中的负载均衡器模块是如何实现的？

> 前面背诵类题目，后面主观回答



#### 项目中的负载均衡器模块是如何实现的？

> 主观回答

我在项目中实现了多种负载均衡算法，包括轮询、随机和一致性 Hash。



#### 什么是一致性 Hash 算法？相比普通的轮询算法有什么优势？

> 背诵类题目

#### 为什么要使用重试机制？有哪些重试策略？项目中的重试机制是如何实现的？

> 前面背诵类题目，后面主观回答

#### 为什么要使用容错机制？有哪些容错策略？项目中的容错机制是如何实现的？

> 前面背诵类题目，后面主观回答

#### 如何简化开发者使用 RPC 框架的成本？怎么通过注解驱动框架的启动？

> 主观回答

#### 在开发过程中，你遇到过比较复杂的技术问题或挑战吗？如果有，请谈谈你是如何解决这些问题的？

> 主观回答，以下仅为一种可行的示例答案



# 趣友阁

#### 1. 为什么要做这个项目？

为了帮大家找到学习伙伴，类似于兴趣小组。比如在大学生之间，可以根据你的年级，你的专业，你感兴趣的技术点，你的目标等作为标签来找到和你一样的人，大家共同学习，共同进步。

#### 2. 介绍一下这个项目

首先你可以注册一个账号，填写你的个人信息。然后可以添加一些标签，比如你是大二，你是计算机专业等。如果你对哪些方面感兴趣，你可以根据标签去搜索一些用户，然后联系他。你还可以创建一个队伍或者叫房间，邀请一些人加入你的房间，你当然也可以解散这个队伍。还能根据标签去搜索队伍，然后加入队伍，也可以退出队伍。系统还可以根据你的标签给你推送一些相似用户，展示在首页。

#### 3. 这个项目里有哪些模块，每个都有什么作用，相互之间是怎么联系的？

主要是用户模块、队伍模块、搜索模块。用户模块的功能主要是注册、登录、个人信息修改、添加和更改标签等。队伍模块的功能主要是创建队伍、解散队伍、加入队伍、退出队伍等。搜索模块的功能主要是根据标签搜索用户和队伍等。

#### 4. 你负责哪些工作？

我负责队伍模块的需求分析，接口开发等。接口开发包括每个接口需要校验哪些参数，完成后需要编写单元测试，还需要和前段对接。

#### 5. 对你来说，有哪些比较难的技术点，你是怎么解决的？

后端如果采用集群模式，假如有 A、B 两台服务器，用户在 A 服务器上登录了，B 服务器上没登录，然后从 B 服务器上来获取用户信息，此时获取不到。因为用户的 session 存储在 A 服务器上，B 没有。可以将 session 存储在公共的地方，比如 Redis 中，这样每台服务器都能获取到，这就是单点登录。直接引入相关依赖，配置一下 session 的存储位置就可以了。

要推荐相似用户，就要计算标签之间的相似度，我在网上最后找到了编辑距离算法这个方法。

首页会推荐标签相似的用户，但是第一次访问时，需要加载 3 s 左右，用户体验不好。利用定时任务每天晚上 12 点查数据库，使用编辑距离算法计算出相似度前 Top N 的用户，缓存到 Redis 中。每天首次访问时直接从 Redis 中去取，这样就可以将时间缩短到零点几秒。但是如果服务器采用集群模式，到点后都会去缓存，造成浪费。所以需要加锁，但是不能用 Java 的锁机制，因为只对单个 JVM 有用。可以使用分布式锁，保证同一时间只有一台服务器来执行定时任务。谁抢到锁谁执行任务，执行完后释放锁。

根据标签匹配用户，一开始使用 SQL 搜索，利用标签关键字去查询时速度较慢。后来改为内存查询，直接查询所有用户放到内存中，然后在根据标签来过滤用户，速度快了 1s 左右。

#### 6. 你为什么要使用这个技术，为什么不使用其他技术？



## 面试题

#### 请介绍一下你在项目中使用的 Redis，它有哪些优势，为什么选择使用 Redis 实现分布式 Session？

Redis 是一个基于内存的 K/V 存储中间件，读写性能高，支持多种数据结构，支持持久化数据。

首先能在分布式场景下保证获取用户信息的一致性。使用非常简便，只需要引入依赖并配置一下就好了。

#### 你在用户登录功能中提到使用 Hash 代替 String 存储用户信息，这样的做法有什么好处？在实际应用中，Hash 与 String 存储方式有哪些区别？

Hash 可以对每个属性进行独立的更新和查询操作，性能更高，更节省内存空间。

#### 请解释一下 Java8 StreamAPI 和 Lambda 表达式的作用，以及在项目中如何应用它们来简化集合处理？

都是 Java8 提供的语法糖，使得集合的处理更加的简洁和高效。

匹配相似用户的时候，使用 sorted 方法进行排序，使用 limit 方法取前几项，使用 map 方法对用户信息进行脱敏。

#### 你是如何自定义线程池的？如何合理设置线程池的参数？

我是使用 ThreadPoolExecutor 实现自定义线程池，并使用 ArrayBlockingQueue 队列来存放任务，我设置了四个参数，分别是核心线程数、最大线程数、空闲线程存活时间、阻塞队列。如果是 CPU 密集型的任务，则将核心线程数设置为 CPU 核心数；如果是 I/O 密集型的任务，则将核心线程数设置为 CPU 核心数的两倍。

#### 你是如何测试批量导入数据库的性能的？用了哪些工具或方法

我编写了一个单元测试类，通过 spring 的 stopWatch 来进行耗时统计。

#### 你在使用 Redis 缓存高频访问用户信息时提到了自定义序列化器，为什么需要自定义序列化器，以及自定义序列化器的实现方式？

由于 Redis 默认使用 JDK 序列化器，不利用阅读和跨语言兼容。所以我自定义了 RedisTemplate Bean 通过相应的方法指定了序列化方式。

#### 你在项目中是如何实现 Redis 缓存的？选用了哪种 Redis 数据结构？

对于登录用户信息的存储，使用依赖和配置来开启 Redis 对分布式 Session 的支持。

对于推荐用户信息的存储，使用 hash 来存储。

#### 使用 Redis 缓存时，有哪些可能出现的常见问题？你又是如何解决的？

1. 缓存雪崩

   - 大量缓存键在相同时间失效，导致大量请求落在数据库上，造成数据库压力激增。
   - 使失效时间分散
   - 提前加载热门数据到缓存中

2. 缓存击穿

   - 热门缓存键过期后，同时有大量并发请求到达，导致直接访问数据库，造成数据库压力激增。
   - 使用互斥锁来保护缓存访问，只允许一个线程生成缓存

3. 缓存过期

   - 数据过期后可能导致数据不一致的情况

   - 设置合理的过期时间，避免数据长时间不更新
   - 检查是否过期，如果过期了，就重新生成缓存

4. 缓存内存过大

   - 数据量很大，导致内存占用过多
   - 设置合理的内存限制
   - 使用 LRU 策略来淘汰不常用的缓存数据

5. 数据一致性

   - 缓存数据和数据库数据不一致
   - 当数据库数据变化时，及时更新缓存

6. 缓存安全

   - 某些敏感数据被缓存
   - 避免缓存敏感数据
   - 使用加密手段来保护缓存数据

在本项目中通过给缓存键设置不同的随机过期时间来解决缓存雪崩问题

#### 在解决首页加载过慢的问题中，你使用了 SpringScheduler 定时任务和分布式锁，请解释一下定时任务的执行原理和此处分布式锁的作用。

给方法增加 @Scheduled 注解，并通过 cronTab 来指定定时任务的时间周期，然后 Spring Scheduler 会在时机到达时开启独立的线程来执行任务。

用分布式锁来保证定时任务执行的唯一性，当要执行时，先去抢锁，抢到锁的服务器才会执行定义任务，而且每个服务器只抢一次。

#### 你在项目中使用 Redisson 分布式锁解决了接口幂等性的问题，请简要介绍一下 Redisson 分布式锁的使用场景和实现原理。

分布式锁的实现是基于 Redis 的 SETNX 命令和 Lua 脚本

1. 获取锁
   - 客户端尝试获得锁时，Redisson 会向 Redis 发送一个 SETNX 命令，将一个特定的键设置为一个特定的值，并设置锁的过期时间。
2. 争用锁
   - 多个客户端同时尝试获取同一个锁时，只有一个客户端能成功设置键的值，其他客户端的命令将失败，并继续尝试获取锁。
3. 锁超时
   - 当锁的超时时间到达后，Redisson 会自动释放锁。
4. 释放锁
   - 客户端执行完锁保护的操作后，可以主动释放锁，这将删除锁的标识键。
5. 锁的可重入性
   - 允许同一个客户端多次获取同一个锁，然后多次释放锁。
6. 锁的续期
   - 锁的超时时间到期后，Redisson 会自动为锁续期。

#### 你提到使用优先队列来减少 TOPN 运算过程中的内存占用，能否解释一下优先队列的特点和在项目中的具体应用

元素按照优先级顺序进行排列，一般优先级越高的元素越早出队，插入和删除效率非常高。

在项目中，使用优先级队列来存储从数据库中查出来的相似度 Top N 的用户，淘汰相似度小于当前 Top N 的用户，存入相似度大于当前 Top N 的用户，将队列元素个数始终维持在 N 个，从而减少内存占用。

#### 编辑距离算法是什么，它在你实现的用户匹配功能中起到了什么作用？请解释一下编辑距离算法的实现原理？

度量两个字符串之间的相似度的算法，常用于字符串相似度比较。

我使用这个算法来计算用户输入的搜索关键词与已有用户的信息匹配程度，并按照相似度排序，从而实现最相似用户的推荐。

给定 word1 和 word2 两个单词，计算出将 word1 转换成 word2 所使用的最少操作数。可以对单词进行三种操作，

删除一个字符、替换一个字符、插入一个字符。

#### 在项目中，你自主编写了 Dockerfile 来实现自动化镜像构建及容器部署，请介绍一下用 Docker 的优势？

Docker 镜像相当于应用安装包，通过编写 Dockerfile 可以来制作 docker 镜像。使用镜像开发者可以一键启动项目，提高应用部署效率。此外，通过给 Docker 镜像标记 Tag 可以控制镜像的版本。

#### 你在项目中使用 Knife4j 和 Swagger 自动生成后端接口文档，请解释一下 Swagger 的作用，以及在项目中使用 Swagger 的好处。

可以根据项目的 controller 接口层自动生成接口文档。支持灵活的在线调试，可以通过界面发送请求来测试接口，提高开发调试效率。



## 真实面经

#### 这个项目开发的背景是什么呢？也是你自己想做的一个项目是吧

为了帮大家找到学习伙伴，类似于兴趣小组。比如在大学生之间，可以根据你的年级，你的专业，你感兴趣的技术点，你的目标等作为标签来找到和你一样的人，大家共同学习，共同进步。

#### 用户登录问题：分布式除了使用 Redis 实现 ，还有哪些实现方式

Session 前端存储：利用用户浏览器中 Cookie 保存 Session 信息。

Session 粘滞方案：利用 Nginx，保证用户的请求都落在同一台机器上。

Session 后端集中存储方案：利用 Redis 集中存储 Session，Web 应用重启或扩容，Session 也无需丢失。

#### 这个标签完全是用户自己填的是吗，还是怎么得到的？

提前准备好了一些标签，让用户去选。

后面的改进思路：让用户填写一些基础的信息，比如说项目经历啊，擅长的语言这种，以数据解析出标签，走用户画像的方向，这样的话对标签拓展有好处。

#### 为了计算用户相似度，使用编辑距离算法，简单说明之后面试官有点没懂就通过举例来解释算法（注意要举简单且有代表性的例子）

（注意这里可以用star法则，什么情况为了解决什么问题，使用了什么技术/方法，实现了什么效果）

面试官提问：举了一个例子问这两个用户的相似度如何计算，进一步提问能否根据标签的类别来计算相似度，比如用户 A：Java；用户 B：Python；用户 C：绘画，编辑距离都是 1，但是 A 和 B 是更相似的，能不能根据标签类别来匹配用户？

（可以想想这里怎么实现，参考其他的标签系统，完善这块的匹配算法！）

面试官建议：标签这块可以扩展的东西还是蛮多的，之后可以做成一个标签系统

#### 介绍组队功能，三种权限的队伍（这里面试官很有可能会问是怎么区分队伍类型的，通过考查实现细节来考查项目的真实性，但是今天没问就简单介绍了一下）

1. 自己加入的队伍，自己不是管理员
2. 自己创建的队伍，自己是管理员

通过特定的字段来区分是否是管理员。

通过那个用户和队伍关系表来维护用户和队伍之间的关系，通过这个表可以根据用户找到队伍，或者根据队伍找到用户，减少关联查询。

#### 如何解决 redis 中的数据和数据库中的数据不一致？

当数据库数据变化时，确保只有一个线程去查数据库，然后更新缓存。

#### 讲一下什么是线程安全？线程池参数有哪些？

是指在多线程环境中，多个线程并发执行某个操作时，不会导致数据不一致、资源竞争或程序崩溃的特性。

参数分别是核心线程数、最大线程数、空闲线程存活时间、阻塞队列。

#### 如何解决多线程环境下线程安全问题？

1. 互斥锁（Mutex / Lock）：

- 通过锁定某个资源，使得在同一时刻，只有一个线程可以访问或修改该资源。
- 例如，Java 中的 `synchronized` 关键字、`ReentrantLock`。

2. 原子操作（Atomic Operations）：

- 利用硬件或操作系统提供的原子操作，保证操作是不可分割的。
- 例如，Java 中的 `AtomicInteger`、`AtomicLong` 等类。

3. 线程局部存储（Thread-local Storage）：

- 每个线程都有自己的私有数据副本，避免多个线程共享数据。
- 例如，Java 中的 `ThreadLocal<T>`。

4. 不可变对象（Immutable Objects）：

- 使用不可变对象（对象的状态在创建后不能被修改）来避免修改共享数据时出现线程安全问题。
- 例如，在 Java 中，`String` 和 `Integer` 类是不可变对象。

5. 并发容器：

- 使用设计上已考虑线程安全的容器类，例如 Java 中的 `ConcurrentHashMap`、`CopyOnWriteArrayList` 等。

#### 学习过消息队列吗？ 什么时候能用到消息队列？

简单了解过，是一种用于在分布式系统中进行异步通信和数据传输的技术，消息队列通过将消息存储在队列中，提供了一种松耦合的通信方式，使得生产者和消费者可以独立运行。

1. 异步处理
   - 当系统需要处理一些耗时的操作时（例如，发送邮件、生成报表、图像处理等）
2. 解耦组件
   - 消息队列可以作为服务之间的通信桥梁，帮助它们松散耦合，减少了直接依赖关系。
3. 流量削峰
   - 使用消息队列可以在高峰时段将请求放入队列，按顺序进行处理，从而避免系统超负荷。
4. 批量数据处理
   - 通过消息队列将任务分批次地提交给消费者进行处理，避免一次性处理过多数据造成性能瓶颈。

#### 使用 redis 缓存后响应时长是怎么测试的？怎么减少响应时长？

看刷新主页推荐用户的时候的加载速度，使用缓存后避免了直接从数据库中查询的耗时操作。

#### 如何使用 redis 实现 redis 缓存的？

项目中有两个地方用到了缓存，一个是用缓存来存储登录用户信息，另一个是用缓存来存储相似度前 Top N 的用户信息。

#### 缓存预热是怎么实现的？

使用定时任务提前查数据库，然后将数据放到 Redis 中进行缓存预热。

面试官提问：这里缓存的是哪些数据呢？是要把全量的用户读取出来吗？（这里忘了读的是哪些用户了直接说的全量，实际应该不是）

首先排除点标签为空的用户，然后只查 id 和标签两个字段。

面试官建议：如果查询全量的话用户量上去之后，比如到了百万级别的话数据库的压力就会比较大（确实）

面试官提问：那你这个定时任务相当于一个旁路是吧，就是不在主服务内是吧（这里不太理解，回答就是在主服务内）

面试官建议：可以考虑使用旁路来做这个定时任务，把一些通用的数据缓存下来，不去刷全量的，这样可能就没这个问题

#### 优先队列：

优先队列是根据优先级来实现出队入队的。

项目中，维护一个优先队列，保持 N 个，比优先队列内优先级低的不选择入队，比优先队列优先级大的，实现入队，并淘汰一个低的，使得队列保持在 N 中，减少内存的使用，Java的优先队列使用 PriorityQueue

具体的实现思路：

1. 创建大顶堆的优先队列。
2. 通过传入比较器创建，泛型是Pair (Pair 是存储键值对的，第一个键是user，第二个是相似度的分数)，
3. 先查询数据库中的所有用户
5. 计算相似度
6. 将之后的用户与登录用户逐一相比较计算分数，将得到的分数与对顶元素的分数相比较，若大于，则不入队；若小于，则删除堆顶元素，插入新元素到优先队列中。优先队列只保留五个元素。
7. 通过Stream 流将优先队列中存储的userid 获取出来，收集为 UserIdList。
8. 根据 UserIdList 查询出最终的用户列表，进行脱敏返回。
