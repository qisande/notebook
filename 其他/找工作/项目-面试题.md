### 面试：

1. 自我介绍：

   我是...

2. 八股文

   1. Java 基础
   2. Java 集合
   3. Java 并发
   4. Java 虚拟机
   5. MySQL
   6. Redis

3. 项目（要有亮点）

   1. 介绍一下项目

      简短，介绍一下有什么模块，模块之间是怎么调用的

   2. 你负责了哪个模块，这个模块是干什么的

   3. 就某一个技术点会深入，问为什么使用这个技术，不用其他技术，用它解决了什么问题

4. 可能有算法



#### API 开放平台项目介绍



#### API 开放平台模块介绍





#### RPC 项目介绍

这个项目功能就是让消费者利用 RPC 框架去调用提供者的服务，不用关心细节，就像调用本地方法一样简单。

调用流程为：消费者调用接口方法，利用动态代理生成接口的代理对象，代理对象利用请求客户端向提供者发送序列化后的请求。提供者的 web 服务器接收到请求后，利用请求处理器将请求反序列化，拿到请求中封装的服务名称、方法名、方法参数类型、具体参数等信息。利用反射调用服务的实现类的方法，拿到返回值，然后再将值封装为响应，发送给消费者。

#### RPC 模块介绍

**全局配置：**

目的：将配置与代码解耦，方便用户定制化开发

在rpc项目启动时，获取到全局配置对象，利用Hutool工具包读取配置文件并生成配置对象，其中使用到了**双检锁单例模式**和懒加载机制。

好处？

这样的好处就是，可以集中管理配置，并减少对象创建。

为什么要用双检锁单例模式？

双检锁是为了保证操作的原子性，保证同一时间只能有一个线程来执行这个操作

什么是懒加载？

需要的时候才创建对象，避免浪费

**接口 Mock：**

目的：有的接口没开发完成，利用代理对象返回假的数据，利于调试，测试，可以快速打通整个开发流程。

**SPI机制：**

目的：实现模块化开发和插件化扩展

SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过反射机制动态加载这些实现，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。

一个典型的SPI应用场景是 JDBC （Java数据库连接库） ，不同的数据库驱动程序开发者可以使用JDBC库，然后定制自己的数据库驱动程序。

**序列化：**

目的：Java 对象不便于在网络传输，所以需要将 Java 对象转化为字节流。

有几种主流的序列化方式，分别是：

json、hessian、kryo、protobuf，这几种方式个有优劣，背一下，因为 json 的易读性好，便于理解和调试，且跨语言支持广泛，所有作为默认的序列化方式

**注册中心：**

目的：帮助消费者获取到服务提供者的地址，将 url 与代码解藕

提供者注册地址等信息到注册中心，消费者从注册中心获取信息，得到地址，通过地址对提供者发起调用

注册中心实现用的是 Etcd

提供者：主要功能是服务注册和心跳检测

服务注册就是将节点信息注册到注册中心

心跳检测是为了检验目标系统的状态，如果系统故障或不可用，从而出发相应的处理或告警机制

实现：用到了 Etcd 的续期机制，给 key 设置过期时间让节点定期续期，到时间没续期就知道服务挂了，将节点信息放到本地集合中，定期扫描集合重新注册。

消费者：主要功能是服务发现，本地缓存，监听机制

服务发现就是从注册中心拿到节点信息，从而去调用服务。将节点信息放到本地 Map 中缓存起来，方面下次使用。

监听机制：当节点信息变化了，需要去更新本地缓存，用到了 Etcd 的监听机制，监听到 key 发生变化时通知消费者。

**自定义协议：**

目的：HTTP 是一个更通用的协议，比较臃肿，而 RPC 模块是定制的，可以自定义更精简的请求头和响应头，减小体积，提高传输效率。

网络传输：采用 TCP 协议，更底层 （传输层）效率高

消息结构：用最少的空间传递必要的信息。

请求头：参考了 Dubbo 的协议设计。请求 id，请求体长度。

另外还需要编码器和解码器

编码器：创建缓冲区对象，将字节数组按顺序依次写入缓冲区

解码器：从缓冲区按顺序依次将字节数组读取

半包和粘包问题：

半包：每次收到的数据更少了

粘包：每次收到的数据更多了

半包解决：在请求头中设置请求体的长度，判断长度是否符合预期，不完整就留到下次再读取

粘包解决：只读取指定长度的数据，超过的留到下次读取

利用 Vert.x 的 RecordParser 来解决，为 Parser 指定读取固定长度的内容，如果请求体每次长度固定，则可以解决。

但是长度是变得，所有调整 RecordParser 读取时的长度，可以分两次来读取

1. 先读取请求头，长度固定，可以完整读取
2. 再读取请求体，根据请求体的长度信息，来设置 RecordParser 读取时的长度

**负载均衡：**

目的：如果有多个服务节点，利用负载均衡可以减轻单个节点的压力，使服务请求比较均匀的分布到各个节点上，增加系统的并发量

轮训：按照循环顺序将请求发配给每个服务器，适用于各服务器性能相近的情况

随机：随机选择一个服务器来处理请求，适用于各服务器性能相近且负载均衡的情况

一致性 Hash：每个节点或服务器，在环状结构上占据一个位置，将请求的哈希值映射到环上一个点，顺时针寻找第一个大于等于其值的点，路由到该节点上。为了使节点在环上更加均匀的分布，可以创建虚拟节点。

计算请求的方法名的 Hash 值，调用一致性 Hash 算法，根据 Hash 值，找到对应的节点，所以方法名相同总会请求到相同的节点上。

**重试机制：**

目的：有时可能会调用接口失败，为了提高系统的可用性，可以进行重试。

重试策略实现：固定重试间隔

使用 Gvava-Retrying 提供的 RetryBuilder 可以很方便的指定重试条件、重试等待策略、重试停止策略、重试工作等。

比如：发生异常时重试，等待 3s，重试 3次后停止，每重试一次还可以执行额外的任务。

**容错机制：**

目的：提高系统的可靠性和健壮性，比如重试一定次数后仍然失败，接下来由容错机制来处理。

重试机制也可以看成容错机制的一种，可以将各种策略来组合使用，比如：

1. 系统调用服务 1 实现网络错误，使用重试。
2. 重试几次失败后，使用降级，改为调用不依赖网络的服务2，完成操作。

1. 快速失败：直接抛出异常
2. 静默处理：直接返回响应

**启动机制和注解驱动：**

目的：让框架更加易用，帮助开发者最少只用一行代码就能使用框架。

启动机制：封装初始化和启动 RPC 框架的代码，如果不是springboot项目，让消费者和提供者仅用一行代码就可以使用 RPC 框架

注解驱动：如果是 springboot 项目，通过扫描注解的方式，来自动化初始化 RPC 框架的过程。

#### 面试题：

**什么是RPC框架？它有什么优点？**

> 背诵类题目

**RPC 和 HTTP 有什么区别？RPC 算是计算机网络哪一层的协议？**

> 背诵类题目，也可以主观回答

**你了解过哪些RPC框架，你的项目和它们相比有什么不同？**

> 前面背诵类问题，后面主观回答

**请介绍整个系统的核心架构设计，有哪些模块？各模块的作用？各模块之间的关系？**

>  主观回答

**什么是 Java 的反射机制，你在项目中是如何应用反射的？**

> 第一问背诵，第二问主观回答

**你在项目中是如何实现消费方调用的？为什么选用 JDK 动态代理和工厂模式？**

> 主观回答，部分可背诵

**为什么选择了 ConcurrentHashMap 来实现本地服务注册器？它的优势是什么？**

> 背诵类题目

**你是如何实现项目中的网络通信的？为什么选择了 Vert.x 框架？**

> 主观回答，部分背诵

**什么是 Hutool 工具库？你在项目中是如何应用 Hutool 工具库提高开发效率的？**

> 主观回答

**你在项目中使用了哪些设计模式？举例说明你是如何应用的。**

> 主观回答

**什么是 Mock？你在项目中如何实现服务 Mock 功能？**

> 第一问背诵，第二问主观回答

**你的 RPC 项目具有哪些配置信息？你是如何读取和管理配置信息的？**

> 主观回答

**什么是序列化和反序列化？你在项目中是如何处理序列化和反序列化的？**

> 第一问背诵，第二问主观回答

**你熟悉哪些序列化协议或类库？它们各有哪些优缺点？**

> 背诵类题目

我熟悉的序列化有：jdk、json、hessian、kryo、protobuf

jdk是java 原生的序列化方式，不用引入额外的依赖，只需实现 Serializable 接口即可。但缺点就是序列化后可读性差，序列化后数据量大，性能差。

> JSON

优点：

- 可读性好，便于理解和调试

- 支持跨语言

缺点：

- 序列化后数据量大
- 不能很好的处理复杂的数据结构和循环引用

> Hessian

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言，适用于分布式系统中的服务调用

缺点：

- 性能低
- 对象必须实现 Serializable接口，限制了可序列化的对象范围

> Kryo

优点：

- 高性能
- 支持复杂的数据结构和循环引用

缺点：

- 不易读懂和调试
- 不支持跨语言

> Protobuf

优点：

- 二进制序列化，序列化后数据量小
- 支持跨语言
- 支持版本化和向前/向后兼容

缺点：

- 不易读懂和调试
- 配置复杂



**什么是 Java 的 SPI 机制？你是如何利用 SPI 机制实现模块动态扩展的？**

> 第一问可背诵，第二问主观回答

SPI 服务提供接口是Java重要的机制，用来实现模块化开发和插件化扩展。

SPI允许服务提供者使用特定的配置文件来将自己的实现注入到系统中，通过反射机制动态加载实现类对象，而不需要修改原始框架的代码，从而实现了系统的解耦，提高了系统的可扩展性。

一个典型的SPI应用就是JDBC，所有的数据库驱动开发者都可以使用JDBC库，定制自己的数据库驱动程序。

1. 定义一个 Map，用来存储健名和实现类对应的映射关系。
2. 编写 SpiLoader类，实现读取配置，加载实现类的方法。
   1. 用 Map 来存储已加载的配置信息键名和实现类的映射
   2. 通过 Hutool 工具库 ResourceUtil.getResource()方法来扫描指定路径，获取到 键名和实现类的信息，存储到Map中。
   3. 从Map中拿到信息，通过反射获取到实现类对象，并维护一个缓存，下次从缓存中读取，提高效率。

3. 重构序列化工厂，使用 SpiLoader 来加载指定的序列化器。

**项目中的服务注册中心有什么作用？是基于什么技术实现的？**

> 主观回答

1. 服务提供者可以将自己的服务信息提交到注册中心。
2. 服务消费者从注册中心获取到服务信息列表，从而完成调用。
3. 定期检查服务提供者的健康状态，发现某个服务不可用，就将其从服务列表中去除，从而保证服务消费者能获取到正常的服务提供者。

是基于Etcd技术实现的。

**为什么用 Etcd 实现注册中心？该技术有哪些优势和特性？**

> 背诵类题目，也可以主观回答

Etcd 是一个 Go 语言实现，开源的，分布式键值存储系统，不要用于分布式系统中的服务发现、配置管理和分布式锁等场景。

特性：

1. 高性能
2. 高可靠，强一致性，使用 Raft 算法来保证数据的一致性。
3. 简单易用，提供了简单的 API
4. 租约机制：用于对键值对设置过期时间，当其过期时，自动将相关的键值对删除。
5. 监听机制：可以监听特定键的变化，变化时可以触发通知。

**服务提供者节点主动下线或宕机时，如何保证注册中心上服务信息的有效性？**

> 主观回答

我设计了节点下线机制，分为主动下线和被动下线

主动下线：利用 JVM 的 shutdownhook，主动从注册中心移除注册信息。

被动下线：利用 Etcd 的 key 过期机制自动移除。

为了保证正常的服务节点的 key 不会被移除，我设计了心跳检测和续期机制，通过定时任务，定期重新注册该服务节点信息，以达到续期的目的。如果该服务器宕机了，那么就不会续期，过期后会被 Etcd 自动移除。

**服务消费者每次都要从注册中心获取服务注册信息么？有没有办法进行优化？**

> 主观回答

不需要，因为注册中心的服务信息列表更新频率不高，所以我设计了一个本地缓存列表，第一次从注册中心获取，然后缓存到本地，下次从本地获取。然后利用 Etcd 的监听机制，监听到相应的 key 发生变化时，删除本地缓存对应的 key 就行了。

**你的 RPC 框架采用了什么协议？为什么要自定义协议？**

> 主观回答

我参考了 Dubbo 的协议设计

1. 自定义了消息结构，设计理念是”用最少的数据传输必要的信息。所以使用了字节数组来拼接消息，消息内容包括消息头和消息体，消息头包括魔数、版本号、序列化、消息类型、状态、请求id和请求体长度信息。
2. 使用 TCP 协议完成网络传输，相比 HTTP 性能更高。

为什么：

1. 更高的性能，减少不必要的数据传输。
2. 更灵活和更好的扩展性，请求头中包含了版本信息，支持向后兼容和协议升级。
3. 更高的安全性，请求头中设置了魔数来进行安全校验。

**什么是 TCP 协议的半包粘包问题？你在项目中是如何解决该问题的？**

> 第一问背诵，第二问主观回答

当客户端像服务端连续多次发送消息时，半包是指服务端收到的消息比客户端单次发送的消息数据少，粘包是指服务端收到的消息比客户端单次发送的消息数据多。

我使用了 Vert.x 框架中内置的 RecordParser 来解决，RecordParser 可以保证下次读取到固定长度的字符，但是消息体的长度是不固定的，所以通过调整 RecordParser 的长度来解决。

将完整的消息读取拆分为两次

1. 第一次只读取消息头，因为长度固定，所以可以保证完整读取。
2. 第二次读取消息体，根据消息头中的消息体长度信息来改变 RecordParser 的固定长度，保证读取到完整的消息体。

**为什么要使用负载均衡？有哪些负载均衡算法？项目中的负载均衡器模块是如何实现的？**

> 前面背诵类题目，后面主观回答



**项目中的负载均衡器模块是如何实现的？**

> 主观回答

我在项目中实现了多种负载均衡算法，包括轮询、随机和一致性 Hash。



**什么是一致性 Hash 算法？相比普通的轮询算法有什么优势？**

> 背诵类题目

**为什么要使用重试机制？有哪些重试策略？项目中的重试机制是如何实现的？**

> 前面背诵类题目，后面主观回答

**为什么要使用容错机制？有哪些容错策略？项目中的容错机制是如何实现的？**

> 前面背诵类题目，后面主观回答

**如何简化开发者使用 RPC 框架的成本？怎么通过注解驱动框架的启动？**

> 主观回答

**在开发过程中，你遇到过比较复杂的技术问题或挑战吗？如果有，请谈谈你是如何解决这些问题的？**

> 主观回答，以下仅为一种可行的示例答案



#### 伙伴匹配项目介绍



#### 伙伴匹配模块介绍