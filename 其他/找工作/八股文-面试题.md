# 设计模式

#### 1123.什么是设计模式？请简述其作用。

设计模式是软件开发人员根据经验总结的一套通用代码设计方案。熟悉了设计模式，遇到类似场景，可以快速找到代码实现模板，加快开发速度，提高代码的可扩展性、可重复性和可维护性。

作用：

1. 帮助快速解决常见问题
2. 提高代码可扩展性
3. 提高代码可重复性
4. 提高代码可维护性
5. 减少沟通成本
6. 提供最佳实践

#### 1124.23种设计模式分为哪三大类？

1. 创建型

   用来创建对象的，隐藏对象创建的逻辑，简化代码。

   常见的有：单例模式、工厂模式和建造者模式

2. 结构型

   用来处理对象组合的关系，关注类和对象的组合。

   常见的有：适配器模式、桥接模式、组合模式和装饰器模式

3. 行为型

   用来定义对象之间的相互协作，以此完成单个对象无法完成的任务。

   常见的有：责任链模式、迭代器模式、观察者模式、状态模式、策略模式和模板模式。

#### 1483.什么是单一职责原则？

单一职责原则是面向对象设计的五大原则之一（SOLID）的 S。

核心思想是：一个类或模块只负责完成一个职责，要设计功能单一即粒度小的类，而不是大而全的类。

作用：

1. 提高系统的可扩展性和灵活性
2. 提高代码的可复用性
3. 降低类的复杂性

#### 1372.什么是开闭原则？

开闭原则是面向对象设计的五大原则之一（SOLID）的 S。

核心思想是：对扩展开放，对修改关闭。新增功能只需要新增代码，不需要修改其他的代码，不会破坏原有的逻辑实现。

#### 1373.什么是里氏替换原则？

里氏替换原则是面向对象设计的五大原则之一（SOLID）的 O。

核心思想是：子类对象可以替换父类对象出现的任何地方，保证程序逻辑正常且不会被修改。目的是为了保持兼容性的前提下扩展和修改。

#### 1374.什么是接口隔离原则

接口隔离原则是面向对象设计的五大原则之一（SOLID）的 L。

核心思想是：调用者不应该被迫依赖它不使用的方法，即一个类对另一个类的依赖应该建立在最小接口上。

作用：

1. 提高代码的可读性
2. 减少代码的冗余
3. 提高系统的可扩展性和维护性

#### 1375.什么是依赖倒置原则

依赖倒置原则是面向对象设计的五大原则之一（SOLID）的 D。

核心思想是：

1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象。
2. 抽象不应该依赖细节，细节应该依赖抽象。

#### 1376.什么是迪米特法则

迪米特法则，又称为最少知识原则。

核心思想是：

1. 一个对象应尽量少的了解其他对象的内部细节。
2. 一个对象应该只与直接的朋友通信，不与朋友的朋友通信。

作用：

1. 降低耦合度
2. 提高系统的可维护性
3. 提高代码的可复用性

#### 1416.谈谈你了解的最常见的几种设计模式，说说他们的应用场景

最常用的就是：单例模式、工厂方法模式、策略模式和模板方法模式

比如支付场景，有支付宝和微信等不同的支付渠道。对于全局配置类和全局缓存等，可以使用单例模式。对于支付服务而言，可以定义一个支付接口，让不同的渠道分别去实现接口，这就是策略模式。整个支付流程包括前置处理、支付动作和后置处理等，这时可以使用模板方法模式。定义一个抽象类，实现前置处理和后置处理等通用流程。把支付的核心动作做成抽象方法，让不同渠道分别去实现。

# Java 基础

#### lava中的序列化和反序列化是什么？



#### 十么是Java中的不可变类



#### lava中Exception和Error有什么区别



#### 尔认为Java的优势是什么



#### 十么是Java的多态特性



#### lava中的参数传递是按值还是按引用



#### 为什么Java不支持多重继承



#### lava面向对象编程与面向过程编程的区别是什么



#### lava方法重载和方法重写之间的区别是什么



#### 十么是Java内部类？它有什么作用



#### JDK8有哪些新特性？



#### Java中String、StringBuffer和StringBuilder的区别是什么？



#### lava的StringBuilder是怎么实现的



#### lava中包装类型和基本类型的区别是什么



#### 爱口和抽象类有什么区别



#### DK和JRE有什么区别？



#### 你使用过哪些JDK提供的工具



#### ava中hashCode和equals方法是什么？它们与==操作符有什么区别？



#### lava中的hashcode和equals方法之间有什么关系？



#### 么是Java中的动态代理



#### DK动态代理和CGLIB动态代理有什么区别



#### lava中的注解原理是什么？



#### 尔使用过Java的反射机制吗？如何应用反射



#### 什么是Java的sPI（ServiceProviderinterface）机制



#### lava泛型的作用是什么？



#### Java泛型擦除是什么？



#### 十么是Java泛型的上下界限定符



#### lava中的深烤贝和浅烤贝有什么区别



#### 什么是Java的Integer缓存池



#### ava的类加载过程是怎样的



#### 十么是Java的BigDecimal



#### 使用newString("yupi”）语句在Java中会创建多少个对象



#### Java中final、finally和finalize各有什么区别？



#### 为什么在Java中编写代码时会遇到乱码问题



#### JDK9中将String的char数组改为byte数组



#### 如何在Java中调用外部可执行程序或系统命令



#### 如果一个线程在Java中被两次调用starto方法，会发生什么



#### 浅和队列在Java中的区别是什么



#### ava的Optional类是什么？它有什么用



#### ava的VO流是什么？



#### 十么是Java的网络编程



#### lava中的基本数据类型有哪些



#### 十么是Java中的自动装箱和拆箱



#### 十么是Java中的选代器（iterator）



#### lava运行时异常和编译时异常之间的区别是什么



#### 十么是Java中的继承机制



#### 十么是Java中的继承机制



#### 十么是Java的封装特性？



#### lava中的访问修饰符有哪些



#### ava中静态方法和实例方法的区别是什么



#### ava中for循坏与foreach循坏的区别是什么



#### 十么是Java中的双亲委派模型



#### ava中waito和sleepo的区别



#### Java和Go的区别



#### lavaObiect类中有什么方法，有什么作用



#### lava中的字节码是什么



#### 十么是BIO、NIO、AIO？



#### 什么是Channel？



#### 什么是Selector？



# Java 集合

#### 说说Java中HashMap的原理



#### 使用HashMap时，有哪些提升性能的技巧



#### 十么是Hash碰撞？怎么解决哈希碰懂



#### 的CopyOnWriteArrayList和Collections.synchronizedList有什么区别？分别有什么优缺点



#### ava中有哪些集合类？请简单介绍



#### 数组和链表在Java中的区别是什么



#### lava中的List接口有哪些实现类



#### 中ArravList和LinkedList有什么区别？



#### avaArrayList的扩容机制是什么



#### lava中的HashMap和Hashtable有什么区别



#### ava中的HashSet和HashMap有什么区别



#### Java中HashMap的扩容机制是怎样的？



#### 为什么HashMap在Java中扩容时采用2的n次方倍



#### 为什么Java中HashMap的默认负载因子是0.75？



#### 为什么JDK1.8对HashMap进行了红黑树的改动



#### DK1.8对HashMap除了红黑树还进行了哪些改动？



#### lava中的LinkedHashMap是什么？



#### lava中的TreeMap是什么



#### lava中的ldentityHashMap是什么



#### Java中的WeakHashMap是什么？



#### Java中ConcurrentHashMap1.7和1.8之间有哪些区别



#### Java中ConcurrentHashMap的get方法是香需要加锁？



#### 为什么Java的ConcurrentHashMap不支持key或value为nullg



#### lava中的CopyOnWriteArrayList是什么



#### 你遇到过ConcurrentModificationException错误吗？它是如何产生的



# Java 并发

#### 什么是Java中的线程同步？



#### lava中的线程安全是什么意思



#### 什么是协程？Java支持协程吗



#### 线程的生命周期在Java中是如何定义的



#### 中线程之间如何进行通信



#### lava中如何创建多线程



#### 你了解Java线程池的原理吗



#### 如何合理地设置Java线程池的线程数



#### lava线程池有哪些柜绝策略



#### lava并发库中提供了哪些线程池实现？它们有什么区别



#### Java线程池核心线程数在运行过程中能修改吗？如何修改



#### Java线程池中shutdown与shutdownNow的区别是什么



#### Java线程池内部任务出异常后，如何知道是哪个线程出了异常



#### lava中的DelavQueue和ScheduledThreadPool有什么区别



#### 什么是Java的Timer？



#### 你了解时间轮（TimeWheel）吗？有哪些应用场景



#### 你使用过哪些Java并发工具类？



#### 什么是Java的Semaphore？



#### 十么是Java的CyclicBarrier？



#### 十么是Java的CountDownLatch？



#### 么是Java的StampedLock？



#### 十么是Java的CompletableFuture



#### 十么是Java的ForkJoinPool3



#### 如何在Java中控制多个线程的执行顺序



#### 你使用过Java中的哪些阻塞队列



#### 尔使用过Java中的哪些原子类



#### 尔使用过Java的素加器吗



#### 什么是Java的CAS（Compare-And-Swap）操作？



#### 说说AQS吧？



#### lava中ReentrantLock的实现原理是什么



#### lava的synchronized是怎么实现的？



#### lava中的synchronized轻量级锁是香会进行自旋



#### 当Java的synchronized升级到重量级锁后，所有线程都释放锁了，此时它还是重量级锁吗



#### 是Java中的锁自适应自旋



#### synchronized和Reentrantlock有什么区别？



#### 如何优化Java中的锁的使用



#### 你了解Java中的读写锁吗？



#### 什么是Java内存模型（JMM）



#### 什么是Java中的原子性、可见性和有序性



#### 什么是Java的happens-before规则



#### 十么是Java中的指令重排



#### lava中的final关键字是否能保证变量的可见性



#### 为什么在Java中需要使用ThreadLocal



#### lava中的ThreadLocal是如何实现线程资源隔离的



#### 为什么Java中的Threadlocal对key的引用为弱引用



#### lava中使用ThreadLocal的最佳实践是什么



#### lava中的InheritableThreadLocal是什么？



#### rhreadLocal的缺点



#### 为什么Netty不使用Threadlocal而是自定义了一个FastThreadlocal？



#### 什么是Java的TransmittableThreadLocal？



#### lava中Thread.sleep和Thread.vield 的区别



#### lava中Thread.sleep（o）的作用是什么？



#### Java中的wait、notify和notifyAII方法有什么作用



#### lava中什么情况会导致死锁？如何避免



#### lava中volatile关键字的作用是什么



#### 十么是Java中的ABA问题



#### 在Java中主线程如何知晓创建的子线程是否执行成功



# Java 虚拟机

#### lava中有哪些垃圾回收算法



#### JVM的TLAB（Thread-LocalAllocation Buffer）是什么



#### lava是如何实现跨平台的？



#### 编译执行与解释执行的区别是什么？JVM使用哪种方式



#### VM的内存区域是如何划分的



#### lava中堆和栈的区别是什么



#### 什么是Java中的直接内存



#### 什么是Java中的常量池？



#### 尔了解Java的类加载器吗



#### 什么是Java中的川（Just-in-Time）



#### 十么是Java的AOT（Ahead-Of-Time）



#### 你了解Java的逃逸分析吗？



#### lava中的强引用、软引用、弱引用和虚引用分别是什么



#### lava中常见的垃圾收集器有哪些



#### lava中如何判断对象是否是垃圾？不同垃圾回收方法有付区别



#### 为什么Java的垃圾收集器将堆分为老年代和新生代



#### 为什么Java8移除了永久代（PermGen）并引入了元空间（Metaspace）



#### 为什么Java新生代被划分为S0、S1和Eden区



#### 什么是三色标记算法



#### lava中的youngGc、oldGc、fullGC和mixedGC的区别是什么



#### 什么条件会触发Java的youngGc？



#### 什么情况下会触发Java的FullGC



#### 十么是Java的PLAB



#### JVM垃圾回收时产生的concurrentmodefailure的原因是什么



#### 为什么Java中CMS垃圾收集器在发生ConcurrentModeFailure时的FullGC是单线程的



#### 为什么Java中某些新生代和老年代的垃圾收集器不能组合使用？比如ParNew和Parallelolo



#### MVM新生代垃圾回收如何避免全堆扫描



#### Java的CMS垃圾回收器和G1垃圾回收器在记忆集的维护上有什么不同



#### 为什么G1垃圾收集器不维护年轻代到老年代的记忆集



#### Java中的CMS和G1垃圾收集器如何维持并发的正确性



#### 什么是Java中的loggingwritebarrier？



#### lava的G1垃圾回收流程是怎样的



#### ava的CMS垃圾回收流程是怎样的



#### 尔了解Java的ZGC（ZGarbageCollector）吗



#### MVM垃圾回收调优的主要自标是什么



#### 如何对Java的垃圾回收进行调优



#### 常用的JVM配置参数有哪些



#### 堂用哪些工具来分析JVM性能



#### 如何在Java中进行内存泄漏分析



# MySQL

## 1.优势

#### 1477.自比于 Oracle，MySQL 的优势有哪些？

1. **MySQL 是免费的。**
2. MySQL 是开源的，有广泛的社区支持和丰富的资料。
3. MySQL 占用资源少，更加轻量。

## 2.优化

#### 1476.为什么不推荐在 MySQL 中直接存储图片、音频、视频等大容量内容？

MySQL 是关系型数据库，**设计的初衷是为了处理结构化和关系型数据**，因此在这方面能力不足。

大容量内容应该存储到文件系统或对象存储系统中，仅在数据库中存储文件的 URL 即可。

#### 629.为什么在 MySQL 中不推荐使用多表 JOIN？

1. **可能会导致性能下降**
   - 在处理大数据集的时候，计算复杂度显著上升，需要进行大量的扫描和匹配，消耗大量的 CPU 和内存资源，增加了响应时间。
2. **可读性和可维护性差**
   - 语句比较复杂，使得后续的调试和优化变得困难。

#### 630.MySQL 中如何解决深度分页的问题？

1. 利用**子查询**扫描二级索引，减少扫描的数据量。
2. 每次分页返回当前的最大 id，下次利用 id 与最大 id 的比较来**过滤**。

#### 4040.MySQL 数据库的性能优化方法有哪些?

优化库表设计、优化 SQL 语句和优化业务。

**库表设计优化**

1. 创建合理的表结构
2. 创建合理的索引，删除不必要的索引。
3. 设计合理的冗余字段，减少关联查询。
4. 对于超大数据量，要考虑分库分表。

> 如何进行 SQL 调优？如何优化慢 SQL？

**查看慢 SQL 日志，利用 EXPLAIN 查询 SQL 的执行计划，找到性能瓶颈，优化 SQL 语句。**

1. 少用 select *，只查询必要字段。
2. 避免在 SQL 中使用函数计算，不然无法命中索引。
3. 避免使用 %LIKE，否则会导致全表扫描。
4. 联合索引要符合最左匹配原则。
5. 不要对无索引的字段进行排序。
6. 进行连表查询时，确保字符集一致，否则会导致全表扫描。

**业务优化**

1. 将频繁查询的数据**缓存**起来。
2. 减少展示不必要的字段。

#### 612.如何使用 MySQL 的 EXPLAIN 语句进行查询分析？

重点看一下查询结果中的几个参数。

- **select_type**：表示查询类型，SIMPLE 代表简单查询、PRIMARY 代表主查询、 SUBQUERY 代表子查询。
- **type**：表示访问类型，REF 代表非唯一索引扫描；RANGE 代表范围扫描，扫描表的一部分；INDEX 代表索引扫描，扫描索引中的所有行；ALL 代表全表扫描，扫描表中的所有行。刚才的顺序为性能从好到差。
- **key**：表示实际用到的索引。
- **rows**：表示大概要读取的行数，行数越少，性能越高。
- **Extra**：表示额外信息，比如显示 using index，表示使用覆盖索引，性能较好。

#### 631.如何在 MySQL 中监控慢 SQL？

利用 MySQL 中的 slow_query_log 参数来监控，它是 MySQL 提供的一个日志功能，用来记录执行时间超过阈值的 SQL 语句。

#### 622.什么是分库分表？分库分表有哪些类型（或策略）？

是**数据库优化性能的一种方法**，通过将数据分散存储在多个数据库和表中，来提高系统的可扩展性、可用性和性能。

1. **垂直分表**
   - 将同一张表的数据按列划分，分散到多个表中。
2. **水平分表**
   - 将同一张表的数据按行划分，分散到多个表中。
3. **垂直分库**
   - 将所有的表按模块划分，分散到多个数据库中。
4. **水平分库**
   - 将相同的表结构复制一份到另一个数据库中。

#### 623.如果组长要求你主导项目中的分库分表，大致的实施流程是？

1. **分析业务需求**
   - 根据数据量以及未来增长趋势，确定到底要不要分库分表。
2. **确定分库分表的方案**
   - 选择合适的分库和分表策略，垂直分，还是水平分。
3. **进行数据路由**
   - 在业务层或者利用数据库中间件，将请求路由到不同的数据库或表。
4. **进行数据迁移**
   - 利用批量导入等方式，将数据导入新的库或表。

#### 624.对数据库进行分库分表可能会引发哪些问题？

1. **首先是事务的问题。**

   - 分库之后单机事务就用不上了，必须使用分布式事务来解决。而分布式事务只能保证最终一致性，所以在**业务上会存在数据不一致的场景**。

2. **连表 JOIN 的问题。**

   - 跨库之后就无法使用 JOIN 了。可以设计冗余字段，来减少关联查询。

3. **全局 ID 唯一性的问题。**

   - 分库分表之后，使用自增 ID 会出现主键重复的情况。可以利用雪花算法来生成唯一 ID。

   > *雪花算法是一种高效且可扩展的生成全局唯一 ID 的方法，适合于大规模分布式系统，确保生成的 ID 唯一且具有时间顺序。*

4. **排序的问题。**

   - 分库分表之后无法使用排序。可以利用数据库中间件的能力来汇总排序。

5. **count 的问题。**

   - 分库分表之后无法使用 count。可以多表 count 后，然后再业务代码中进行累加。

#### 618.如何在 MySQL 中避免单点故障？

一般是采用**主从架构**来避免单点故障，主数据库负责写操作，从数据库负责读操作，主数据库发生故障时，随时切换到从数据库。

**定期备份数据**到不同的物理系统，以便发生故障时能快速恢复。

建立完整的**监控系统**，实时监测数据库的健康状态，发生故障时及时告警。

#### 618.如何在 MySQL 中实现读写分离？

**做法一：代码封装**

使用代理类，对外暴露读写接口，读操作指向从数据库，写操作指向主数据库。

- 优点：简单、灵活。
- 缺点：数据库宕机了，则需要修改配置，重新启动。

**做法二：使用中间件**

客户端连接中间件，中间件连接数据库，它们之间使用 SQL 协议交互。

- 优点：屏蔽了多语言的差异。
- 缺点：需要多维护一个系统，而且可能成为性能瓶颈。

#### 620.什么是 MySQL 的主从同步机制？它是如何实现的？

是一种**数据复制技术**，将主数据库中的数据复制到一个或多个从数据库中。

主要是通过二进制日志（binLog) 实现的。主数据库在进行写操作时，会将操作写入到 binlog 日志中，然后推送给从库。从库重放对应的日志即可完成复制。

#### 621.如何处理 MySQL 的主从同步延迟？

首先无论怎么优化，**延迟是必然存在的**，所以只能减少延迟时间。

1. **二次查询**
   - 如果从库查不到数据，就去主库再查一遍。
2. **关键业务读写都走主库**，非关键业务还是读写分离。
3. **使用缓存**，将数据写入到主数据库后，可以在同步到缓存中，这样查询时可以先从缓存中查。

## 3.实现

#### 617.MySQL中的数据排序是怎么实现的？

如果字段命中索引则使用**索引排序**，反之，使用**文件排序**。

使用文件排序时，如果数据量小，则利用内存排序，分为单路排序和双路排序。

> **双路排序：**
>
> *select 的字段的单行数据大小超过 4kB 时，为了节省排序占用的空间，内存中只会放置主键和要排序的字段，排序后，再通过主键回表查询得到其他字段的值，再将完整的结果集返回。因为需要两次查询，所以叫双路排序。*
>
> **单路排序：**
>
> *一次性所有 select 的字段放到内存中进行排序，没有回表过程，直接返回结果集。*

如果数据量大，则利用磁盘进行外部排序，一般使用归并排序。

#### 3179.如何实现数据库的不停服迁移?

- 首先考虑**量级**，如果是几十万条数据，则用代码迁移，大致比对一下就行了。如果数据量很大，则要好好考虑方案。
- 其次需要考虑**数据的插入和修改**，要保证数据一致性。
- 再然后需要考虑**回滚**，一旦发生意外，要及时切换回旧数据库，保证业务不受影响。

## 4.区别

#### 590.MySQL 的存储引擎有哪些？它们之间有什么区别？

1. InnoDB
   - 支持事务、外键和行级锁。
   - 支持高并发场景，适合高负载的应用。
   - 数据以聚集索引的方式存储，检索性能较高。
2. MyISAM
   - 不支持事务、外键和行级锁，支持表级锁。
   - 适合读取多，更新少的场景，如数据仓库。
   - 具有较高的读性能。

#### 4943.什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？

逻辑删除是指在表中增加一个判断是否删除的字段，如 is_deleted，0 表示未删除，1 表示已删除。

物理删除是指从数据库中删除记录。

#### 4944.什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？

逻辑外键是在**应用程序层面上**利用代码来保证引用的完整性，而不是利用数据库的物理外键。

**逻辑外键：**

优点：

- 灵活性高
- 跨数据库兼容性好

缺点：

- 代码复杂性增加
- 维护成本高

**物理外键：**

优点：

- 减少应用层复杂度
- 自动维护引用完整性

缺点：

- 灵活性差
- 跨数据库兼容性差

#### 615.MySQL 中 varchar 和 char 有什么区别？

都是存储字符串的列类型。

char：固定长度字符串，占用固定的存储空间。字符串长度小于定义的长度时，MySQL **会在字符串后面填充空格**。

varchar：可变长度字符串，占用实际需要的存储空间。字符串需要多 1 到 2 个字节来存储长度信息。

#### 1478.MySQL 中 VARCHAR(100) 和 VARCHAR(10) 的区别是什么？

能存储的**字符串长度上限不同**，前者最多能存储 100 个字符，后者最能存储 10 个字符。

当存储的**字符串相同**时，占用的空间相同。

查询时，前者比后者占用的内存空间更多。

#### 613.MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？

都是**用来统计行数的聚合函数**，但在功能和效率上有些区别。

**功能上：**

1. count(*)  和  count(1)  都是统计全表行数，包括 null。
2. count(字段名) 只统计指定字段不为 null 的行数。

**效率上：**

1. count(*)  和  count(1)  效率一致。
2. count(字段名) 进行的就是全表扫描，还要判断字段是否为 null，所有会比前两个慢。

#### 632.MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？

delete 删除行数据，保留表结构和相关的对象。

drop 删除数据库表，包括表结构和数据。

truncate 删除表数据，保留表结构和索引。

#### 633.MySQL 中 INNER JOIN、LEFT JOIN 和 RIGHT JOIN 的区别是什么？

**inner join：**

- 只返回两个表中匹配的行
- 适用于只关心**交集数据**的场景

**left join：**

- 返回左表中的所有行，如果右表没有匹配的行，则结果中的右侧列为 NULL。
- 适用于需要保留**左表所有数据**的场景。

**right join：**

- 返回右表中的所有行，如果左表没有匹配的行，则结果中的左侧列为 NULL。
- 适用于需要保留**右表所有数据**的场景。

#### 1214.MySQL 中 LIMIT 100000000, 10 和 LIMIT 10 的执行速度是否相同？

执行速度相差很大。

1. LIMIT 100000000, 10

- 需要先处理前1一亿条数据，然后从中获取到需要的10条记录，会造成大量的磁盘 I/O 操作，成本开销很大。

2. LIMIT 10

- 从第一条数据开始记录，获取到需要的 10 条记录。执行速度快。

对于这种大分页的情况，可以先使用主键 id 进行范围过滤。

#### 1217.MySQL 中 DATETIME 和 TIMESTAMP 类型的区别是什么？

datetime：以字符串形式存储，占 8 个字节。不受时区影响，不会根据时区自动转换。

timestamp：以 Unix 时间戳形式存储，占 4 个字节。受时区影响，会根据时区自动转换。

## 5.过程

#### 589.详细描述一条 SQL 语句在MySQL中的执行过程。

连接器 -> 分析器 -> 优化器 -> 执行器

1. 先通过连接器校验权限。
2. 利用分析器进行词法分析和语法分析，构建解析树。
3. 利用优化器选择合适的索引和表连接顺序，最终选择一个最佳的执行计划。
4. 利用执行器调用引擎层查询数据，返回结果集给客户端。

#### 600.请详细描述 MySQL 的 B+ 树中查询数据的全过程

1. 从根节点开始，根据键值选择查左子树还是右子树，最终找到叶子节点。
2. 叶子节点中存储的是实际的数据行记录，每一页有 16kb 大小，存储了很多行数据。
3. 数据行是分组的，根据**页目录**，通过二分查找，找到对应的组。
4. 最后通过链表找到最终的数据行。

## 7.索引

#### 591.MySQL 的索引类型有哪些

从**数据结构**的角度来看：

1. B+树索引
2. 哈希索引
3. 倒排索引
4. R-索引

从**基于 InnoDB B+树索引**角度来看：

1. 聚簇索引
2. 非聚簇索引

从**索引性质**的角度来看：

1. 普通索引
2. 主键索引
3. 联合索引
4. 唯一索引
5. 全文索引
6. 空间索引

#### 601.为什么 MySQL 选择使用 B+ 树作为索引结构？

1. **高效的查询性能**。B+ 树是一种自平衡树，插入、删除和更新等操作的时间复杂度为O(logn)，在数据量较大的情况下，也能有较快的响应。
2. **树的高度增长较慢，查询磁盘 I/O 次数少**。非叶子节点只存储键名和指针，所以索引可以存储更多的数据行。内存中可以存储更多的索引，提高命中缓存的几率，减少查询磁盘 I/O 的次数。
3. **范围查询能力强**。因为叶子节点通过链表链接，只需要顺着链表查询就可以查询到前后的数据，非常高效。

#### 597.在 MySQL 中建索引时需要注意哪些事项？

1. **索引并不是越多越好**，因为索引会占据空间。
2. **字段里的值有大量重复的，最好不要建立索引**。
3. 对于 text、longtext 这些**长字段最好不要建立索引**，因为会占用大量内存。
4. **修改的频率远大于查询的频率时**，最好不要建立索引，因为索引会减慢修改的效率。
5. 当字段作为频繁查询的条件时，最好建立索引。**如果有多个字段，最好建立联合索引**。
6. 对于经常在分组、排序和去重后面的字段，最好建立索引。

#### 598.MySQL 中使用索引一定有效吗？如何排查索引效果？

**不一定有效**，有些情况下就没用上索引，比如：

1. 查询条件中的列不在索引中，或者查询条件复杂且与索引顺序不匹配。
2. 查询的表比较小，全表扫描的效率更高。

总之，用不用索引，是 MySQL 评估 CPU 和 I/O 成本，计算后决定的。

**排查索引效果**可以在执行的 SQL 语句前加上 EXPLAIN，可以查看 MySQL 选择的执行计划。主要看 type、key 和 rows 这三个参数。type 为 index 和 range 表示用上了索引；key 不为 null 表示用上了索引；rows 表示评估的扫描量，扫描量越少，响应越快。

#### 599.MySQL 中的索引数量是否越多越好？为什么？

**索引并不是越多越好**，**时间和空间上都是有成本的**。

1. **从时间上来说**。当进行写入操作时，**索引越多需要修改的地方就越多**，意味着时间开销越大。
2. **从空间上来说**。每建立一个二级索引，都需要新建一个 B+ 树，所以索引越多占用空间越大。

#### 594.MySQL 索引的最左前缀匹配原则是什么？

指的是使用**联合索引**的时候，查询条件必须从最左侧开始匹配，如果一个联合索引包含多个字段，查询条件必须包含第一个字段的条件，然后是第二个字段，以此类推。

#### 1479.在什么情况下，不推荐为数据库建立索引？

1. 数据量小的表
2. 频繁修改的表
3. 需要执行大量 select *的表
4. 值大量重复的字段
5. 查询频率低的字段
6. 长文本字段

#### 592.MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？

**聚簇索引**

1. 索引叶子节点存储的是数据行，可以直接访问完整数据。
2. 一个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序。

**非聚簇索引**

1. 索引叶子节点存储的是主键和索引列，需要根据主键再次查询才能访问到完整的数据。
2. 一个表可以有多个非聚簇索引，适合快速访问特定的列。

#### 595.MySQL 的覆盖索引是什么？

是指二级索引中包含了查询需要的所有字段，使查询可以仅通过访问二级索引。

#### 596.MySQL 的索引下推是什么？

是一种减少回表查询的操作，提高查询效率。当 MySQL 使用索引查询数据时，将部分查询条件下放到存储引擎层过滤。减少了从表中读取的数据行，减少了 IO，将本该由 Server 层完成的操作，交给存储引擎层完成，因此叫做“下推”。**索引下推是应用在联合索引上的。**

## 8.事务

#### 602.MySQL 是如何实现事务的？

主要通过**锁、Redo Log、Undo Log 和 MVCC** 来实现事务。

1. 利用锁的机制，实现数据并发修改的控制，实现事务的隔离性。
2. 利用 Redo Log（重做日志）记录事务对数据库的所有更改，再发生崩溃时恢复未提交的更改，实现事务的持久性。
3. 利用 Undo Log（回滚日志）保存数据的历史版本，在事务操作失败时，回滚到之前的版本，实现事务的原子性和隔离性。
4. 利用 MVCC （多版本并发控制）满足未锁定读的需求，实现读已提交和可重复读的两种隔离级别。实现事务的隔离性。

#### 603.MySQL 中长事务可能会导致哪些问题？

1. **阻塞资源**。
   - 常事务持有锁的时间较长，容易导致其他事务在获取相同锁的时候阻塞，增加系统等待时间和影响并发性能。
   - 业务系统会因为常事务的阻塞而阻塞，容易导致其他服务受到影响，从而导致服务全面崩盘，造成严重的线上事故。
2. **造成死锁**。
   - 多个事务可能在等待对方互相释放锁，造成系统无法继续执行。
3. **主从延迟。**
   - 主数据库执行很长时间后，才能同步数据给从库，在这个长时间的等待中会造成数据的不同步。
4. **浪费时间**。
   - 常事务可能执行了很长时间后因为异常导致失败，那么之前的执行就都浪费了。

#### 604.MySQL 中的 MVCC 是什么？

是一种并发控制机制，允许多个事务同时进行读取和写入的操作，不会阻塞，提高并发性能。

MySQL 会为每一个事务创建一个数据快照，当修改数据时，不会立刻覆盖原数据，而是会生成一个新的有特定版本号的版本记录。

所有的版本记录会串成一条版本链，在不同时刻启动的事务可以**无锁地**获得不同版本的数据，读写操作不会阻塞。

写操作会继续写，无非生成一个新的版本记录，历史版本记录可供已启动的事务读取。

#### 605.如果 MySQL 中没有 MVCC，会有什么影响？

如果没有 MVCC，那么系统就需要频繁的对读写操作加锁，以此来保证数据的一致性。因为增加了获取和释放锁的开销，会导致系统整体响应速度变慢，这种实现叫 LBCC。

#### 606.MySQL 中的事务隔离级别有哪些？

1. **读未提交**
   - 这是最低的隔离级别，一个事务可以会看到另一个事务未提交的数据，可能导致**脏读**问题，即读到其他事务未提交的数据。
2. **读已提交**
   - 一个事务只能看到其他已提交事务的修改。可以避免脏读问题，但是可能会导致**不可重复读**的问题，即同一个事务中相同查询可能返回不同的查询结果。
3. **可重复读**
   - 在同一个事务中多次查询返回的结果相同，可以避免不可重复读的问题。但有可能会导致**幻读**的问题，即多次查询返回不同数量的行。（MySQL 默认）
4. **串行化**
   - 这是最高的隔离级别，每个事务都会等待前一个事务执行完毕后再执行，可以避免所有的并发问题，但会大大降低性能。

#### 607.MySQL 默认的事务隔离级别是什么？为什么选择这个级别？

默认是可重复读。原因是为了兼容早期 binlog 的 statement 格式。如果是使用读未提交和读已提交的话，使用了 statement 的 binlog 会导致主从数据库的数据不一致问题。

#### 1535.你们生产环境的 MySQL 中使用了什么事务隔离级别？为什么?

MySQL 默认的是 RR（可重复读），改成了 RC（读已提交），为了**提高并发量和降低死锁的概率**，因为 RC 中修改数据仅用行锁，锁定的范围更小。

#### 608.数据库的脏读、不可重复读和幻读分别是什么？

1. **脏读**
   - 一个事务读取到另一个事务未提交的修改，如果未提交的事务最终被回滚，那么第一个事务读取到的数据就是不一致的。
2. **不可重复读**
   - 例如，事务 A 读取了一行数据，事务 B 修改并提交了这行数据，导致事务 A 再次读取时得到不同的值。
3. **幻读**
   - 事务 A 查询某条件的记录，事务 B 插入了新的记录并提交，导致事务 A 再次查询时看到不同的记录数量。

## 9.锁

#### 609.MySQL 中有哪些锁类型？

1. **共享锁**
   - 允许事务并发访问同一个资源，不允许修改。只有释放共享锁后，其他事务才能获得排他锁。
2. **排他锁**
   - 只允许一个事务对资源进行读写操作，其他事务在获得排他锁之前无法访问。

3. **行级锁**
   - 加在特定的行上，允许其他事务并发访问不同的行，适用于高并发场景。

4. **表级锁**
   - 加在特定的表上，其他事务无法对该表进行任何的读写操作，适用于小型表。

5. **间隙锁**
   - 加在索引的两个记录之间的间隙，防止其他事务对这个间隙插入新记录，以避免幻读。

6. **临键锁**
   - 是行级锁和间隙锁的结合，锁定具体行和其前面的间隙，常用于可重复读的隔离级别。

7. 意向锁
   - 用于表示某个事务对某行数据加锁的意图，分为意向共享锁和意向排他锁。主要用于行级锁和表级锁的结合。

8. 插入意向锁
   - 一种特殊的意向锁，用于表示某个事务对某个间隙插入记录的意图。

9. 自增锁
   - 再插入自增列时，加锁以保证自增值的唯一性。

#### 610.MySQL 的乐观锁和悲观锁是什么？

**悲观锁：**

- 假设会发生冲突，因此在操作数据之前就**对数据加锁**，防止其他事务进行读写操作。用在对数据一致性要求较高的场景。
- 实现方式：利用行级锁或表级锁。

**乐观锁：**

- 假设不会发生冲突，因此在操作数据之前不加锁，而是在更新数据时**进行版本控制或校验**。发现其他事务修改了数据，则放弃当前事务的本次修改，需重新尝试。
- 实现方式：利用版本号或时间戳进行校验，每次更新时检查版本号或时间戳是否一致。

#### 611.MySQL 中如果发生死锁应该如何解决？

**自动检测与回滚：**

- MySQL 自带死锁自动检测机制，检测到发生死锁时，选择其中一个事务进行回滚，以解除死锁。
- 当获取锁等待时间超过阈值时，就释放锁进行回滚。

**手动 kill 发生死锁的语句**

- 可以通过命令手动快速查询发生阻塞的事务和线程 ID，手动 kill 掉线程，以释放资源。

## 10.是什么

#### 1219.数据库的三大范式是什么？

**第一范式（1NF）**

- 不允许重复的列和多值字段。

**第二范式（2NF）**

- 非主键字段必须依赖于整个主键。

**第三范式（3NF）**

- 非主键字段只能依赖于主键，不能相互依赖。

#### 593.MySQL 中的回表是什么？

“回表“是指在使用”二级索引作为条件进行查询时，由于二级索引中只存储了索引列的值和主键，没有其他数据，如果要得到其他数据，需要根据主键去聚簇索引查询实际的数据行，**这个过程被称为“回表”。**

#### 614.MySQL 中 int(11) 的 11 表示什么？

11 表示**显示宽度**，表示并不影响存储大小和显示范围。

**显示宽度**：使用 ZEROFILL 参数时，如果字段的位值不满 11 位，则前面会填充 0。

**存储大小**：int 类型始终占 4 个字节。

#### 625.MySQL 获取数据，是从磁盘读取的吗？

**并不总是直接从磁盘读取的**，MySQL 有缓存机制。当查询数据时，如果内存中有，则访问内存返回数据，否则从磁盘读取数据并加载到缓存中。

#### 626.MySQL的 Change Buffer 是什么？它有什么作用？

它是 InnoDB 的一个机制，**用于暂存对二级索引的插入和更改操作**，不立即执行这些操作，当条件合适时，InnoDB 会把这些更改写入到二级索引中。

作用：

1. **提高性能**：因为更改被暂存，减少了对磁盘的频繁写入，提高了性能。
2. **批量处理**：Change Buffer 会在后续的操作中批量处理这些更改，减少了随机写入的开销。

#### 627.MySQL 的 DoublewriteBuffer 是什么？它有什么作用？

是 InnoDB 引擎的一个机制，一个内存缓冲区，用来保证数据的安全性和一致性。

**工作原理：**

- 写入：当使用事务向数据库写入数据时，会先写入 Doublewrite Buffer 中，然后从缓冲区中将数据写入到磁盘的实际文件中。
- 恢复：写入磁盘的过程中，发生断电等意外情况时，将数据从 Doublewrite Buffer 中恢复到实际文件中。

#### 628.MySQL 中的 Log Buffer 是什么？它有什么作用？

是一个内存区域，用来暂存事务日志的数据。通过批量写入操作将日志数据一次性写入到磁盘中，减少 I/O 操作，提高性能。

#### 1418.什么是数据库的视图？

是一个**虚拟表**，不存储实际的数据，通过查询其他表的数据来生成。包含一个或多个表的数据，可以对这些数据进行筛选、计算和排序操作。使用视图可以增强数据的安全性。

#### 1419.什么是数据库的游标？

是一个**数据库对象**，使得应用程序可以逐行访问查询结果集，而不是一次性处理所有结果。

## 11.其他

#### 1376.在 MySQL 中，你使用过哪些函数？

字符串函数：length、concat、substring等。

#### 1377.MySQL 中 TEXT 类型最大可以存储多长的文本？

**tinytext：**255 字节。

**text：**64kB 字节。

**mediumtext：**16MB 字节。

**longtext：**4GB 字节。

#### 1378.MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？

达到最大值后，会继续申请下一个 ID，值不变，导致报重复值的错误。

#### 1379.在MySQL中存储金额数据，应该使用什么数据类型？

bigint 和 decimal，**bigint 在代码中对应 long，decimal 在代码中对应 BigDecimal**。

#### 1482.MySQL 中 EXISTS 和 IN 的区别是什么？

exists：用于判断子查询是否返回任何行。适用于外层查询表量级小于子查询表，且子表有索引。

in：用于检查某个值是否在指定的集合中。适用于外层查询表量级大于子查询表，且外层表有索引。

#### 1534.什么是 Write-Ahead Logging(WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？

是一种数据库事务日志管理系统，核心思想是，**先写日志，在写数据**。，大致流程如下：

1. 在事务开始时，先将对数据库的修改记录到日志中。
2. 确保日志安全写入磁盘后，再将这些修改应用到数据库文件中。

优点：

- 保证数据一致性。
- 性能提升。

用到了，重做日志（Redo Log）就是 WAL 的实现。

#### 1218.为什么阿里巴巴的 Java 手册不推荐使用存储过程?

1. 可移植性差
2. 调试困难
3. 维护复杂

#### 2629.MySQL 中 InnoDB 存储引擎与 MyISAM 存储引擎的区别是什么？

**MyISAM：**

1. **不支持事务和行级锁，只有表级别锁。**
2. 不支持崩溃后的安全恢复。
3. 写入性能差

**InnoDB：（默认）**

1. 支持事务和行级锁。
2. 支持外键。
3. 并发性能好。

#### 2640.MySQL 的查询优化器如何选择执行计划？

1. 将 SQL 语句解析为解析树。
2. 预处理，比如进行语法检查、校验权限和查询重写。
3. 生成多个执行计划，选择成本最低的。

#### 9498.MySQL 事务的二阶段提交是什么？

是 MySQL 确保 redo log 和 binlog 的一致性而使用的一种机制。主要是为了在崩溃恢复时不会出现**数据丢失和不一致**的情况。

分为**准备和提交两个阶段**，先写 redolog 此时状态为 prepare，再写 binlog，然后再把 redolog 的状态改为 commit。

#### 9499.MySQL 二层 B+ 树能存多少数据？

按每条记录 1 kB 算，每个指针 6 字节，索引键 8 字节，每个节点页大小 16kB，大约能存储 2000 万条记录。

# Redis

## 1.优势

#### 5206.Redis 源码中有哪些巧妙的设计，举几个典型的例子？

巧妙的设计主要包括：线程模型、数据结构、共享对象池、过期设计、数据持久化设计。

- 采用单线程模型，减少上下文切换开销。并使用多路复用和事件驱动机制，来处理大量并发请求。
- 采用动态字符串设计，提高安全性；利用压缩列表来存储数据，节省内存；采用渐进式 rehash 方式，避免了集中的性能抖动。
- 使用共享对象池来存储常用的小整数，减少了内存分配和释放的开销。
- 对于过期键，采用惰性删除确保性能，同时利用定期删除避免内存泄漏。
- 利用 AOF 重写机制来确保数据安全。

#### 635.Redis 为什么这么快？

1. 将数据存储在内存中，提供快速的读写速度。
2. 使用单线程事件驱动模型和 I/O 多路复用技术，减少上下文切换。
3. 提供多种高效的经过优化的数据结构。

#### 640.Redis 和 Memcached 有哪些区别？

Redis 支持多种数据结构，支持持久化功能。

Memcached 仅支持键值对存储，不支持持久化。

## 2.优化、解决问题

#### 646.Redis 中的 BigKey 问题是什么？如何解决？



#### 647.如何解决 Redis 中的热点 key 问题？



#### 668.Redis 性能瓶颈时如何处理？



#### 937.Redis 中的内存碎片化是什么？如何进行优化？



## 3.实现、原理，功能、机制

#### 638.Redis 中跳表的实现原理是什么?

主要通过**多层链表**实现，底层链表保存所有元素，而每一层都是下一层子集。

- **查找时**，从最高层开始，逐层向下，直到找到目标元素。
- **插入时**，从最高层开始查找插入位置，随机决定新节点层数，然后在相应层插入节点。
- **删除时**，从最高层开始查找删除位置，并更新各层中的指针，保持跳表的结构。

#### 636.为什么 Redis 设计为单线程？6.0 版本为何引入多线程？

1. 性能瓶颈主要不是 CPU 导致的。

2. **减少线程上下文切换带来的开销。**
3. 在单线程下，使用 I/O 多路复用模型就可以提高 I/O 利用率了。

#### 644.Redis 的 Lua 脚本功能是什么？如何使用？



#### 645.Redis 的 Pipeline 功能是什么？



#### 649.Redis 在生成 RDB 文件时如何处理请求？



#### 654.Redis 的计阅发布功能是什么？你了解吗？



#### 827.Redis 中 EMBSTR 对象的副值设置为何为 44？其调整历史是什么？



#### 939.Redis 的虚拟内存（VM）机制是什么？



## 4.数据结构

#### 637.Redis 中常见的数据类型有哪些？

常见的数据类型主要有 5 种，分别为：String(字符串)、List(列表)、Hash、Set(集合)、Sorted Set(有序集合)

**String**

字符串是 Redis 种最基本的数据类型，可以存储任何类型的数据。

**使用场景：**

- 缓存：存储用户会话等。
- 计数器：统计点赞数等。

**List**

列表为有序的字符串集合，支持从两端推入和弹出元素。底层实现为双向链表。

**使用场景：**

- 消息队列：用于消息传递等场景。
- 历史记录：用于存储用户的历史记录。

**Hash**

哈希是一个键值对集合，底层实现为哈希表。

**使用场景：**

- 商品详情：存储商品的各个属性。

**Set**

集合是无序且不重复的字符串集合，底层为哈希表。

**使用场景：**

- 标签系统：存储用户的唯一标签，避免重复。

**Sorted Set**

有序集合类似于集合，但每个元素都有一个分数，底层实现为跳表。

**使用场景：**

- 排行榜：实现各种实时排行榜。
- 任务调度：根据任务的优先级排序，方便调度执行。

#### 639.Redis 的 hash 是什么？

是一种**键值对集合**，适合存储对象类型的数据。具有**内存高效和灵活性强**的特点。

负载因子：保存的节点数量 / 哈希表大小

扩容：

- **负载因子大于等于 1 时**。
- 首先创建一个新表，大小大概为旧表的 2 倍。每次进行增删改查操作时，都进行一次数据迁移，**所以扩容是分多次，渐进式完成的**。

缩容：

- 负载因子小于等于 0.1 时。
- 过程与扩容一样。

#### 661.Redis String 类型的底层实现是什么?



#### 665.Redis 中的 Geo 数据结构是什么？



#### 667.Redis 字符串类型的最大值大小是多少？



#### 881.如何在 Redis 中实现队列和栈数据结构？



#### 882.Redis 中的 ziplist 和 Quicklist 数据结构的特点是什么？



#### 886.Redis 的 ListPack 数据结构是什么？



## 5.一致性、事务

#### 641.Redis 支持事务吗？如何实现？

Redis **支持事务**，但与 MySQL 中的事务不一样。

Redis 中的事务主要保证命令执行的原子性，且不支持事务回滚。

MySQL 中的事务主要保证 ACID 的特性，而且支持回滚。

Redis 的事务不是我们理解的传统事务。

#### 642.Redis 数据过期后的删除策略是什么？

分为定期删除和惰性删除两种。

- **定期删除：**Redis 每隔一段时间，随机检查一定数量的键。如果发现过期，则将其删除。
- **惰性删除：**每次访问键的时候，检查是否已过期，如果过期了，则将其删除。

#### 643.Redis 中有哪些内存淘汰策略？

一共有 8 种，分为开启数据淘汰和不开启数据淘汰。不开启数据淘汰又分为全部数据的淘汰策略和基于过期时间的淘汰策略。

不淘汰数据（默认）

- noeviction：运行内存超过设置的内存时，不淘汰数据而是报错，禁止写入。

全部数据的淘汰策略

- allkeys-lru：淘汰掉最久没使用的 key。
- allkeys-lfu：淘汰掉最少使用的 key。
- allkeys-random：随机淘汰任意的 key。

基于过期时间的淘汰策略

- volatile-ttl：优先淘汰掉较早过期的 key。
- 其他和上面一样，只不过是基于过期时间。

#### 648.Redis 的持久化机制有哪些？

RDB

- 通过创建快照来获取内存某个时间点上的副本，定期保存。

AOF

- 将每个写操作追加到日志文件中，比 RDB 机制更加可靠。

#### 660.Redis 中如何保证缓存与数据库的数据一致性？

- 先更新数据库，再删除缓存。后续等查询时再将数据库中的数据回种到缓存中。
- 坚挺数据库的 binlog 变化，通过异步的方式更新缓存。

考虑实时一致性的话使用第一种，考虑最终一致性的话使用第二种。

#### 884.Redis 事务与关系型数据库事务的主要区别是什么？

同 641 题。

## 6.分布式、集群

#### 651.Redis 主从复制的实现原理是什么？

一个主节点讲数据复制到多个从节点，并保持同步。

复制流程：

- **连接：**从节点向主节点发送 PSYNC 命令来建立连接。
- **全量复制：**如果是第一次或之前失败了，则从节点请求全量复制，主节点将数据快照，即 RDB 文件，发送个从节点。
- **增量复制：**之后保持长连接将后续的写操作发送给从节点，来保证数据一致性。

#### 652.Redis 集群的实现原理是什么？

集群是通过多个 Redis 实例组成的，每个实例只存放部分数据。

利用**哈希槽**机制来分配数据。将键值空间划分为 **16384 个槽**，每个节点拥有一部分槽位。每个键值根据哈希算法映射到一个槽位，通过槽位可以找到对应节点。

客户端发送请求到集群中的**任意一个节点**，如果有数据泽直接返回，反之，则根据键值计算哈希槽并路由到正确节点。

#### 650.Redis 的哨兵机制是什么？

是一种高可用性解决方案，用于监控主从集群，**自动完成主从切换**，以此实现故障恢复和通知。

功能：

- **监控**节点的运行状态，检查节点是否正常。
- 主节点发生故障时，**选举出新的主节点**。
- 向其他服务**发送状态通知**。

#### 653.Redis 集群会出现脑裂问题吗？

可能会，特别是在**网络分区**的情况下，同一集群内可能出现多个主节点，导致数据不一致。

#### 883.Redis 复制延识的常见原因有哪些？

- 网络原因，比如网络抖动等。
- 主节点负载过高，来不及向从节点发送复制数据。
- 从节点配置较差。

#### 885.Redis cluster 模式与 Sentinel 模式的区别是什么？

需要处理大量数据并进行数据分片的话，选 Redis Cluster 模式。

为了提高 Redis 实例的可用性，选 主从 + Sentinel 模式。

#### 838.Redis 主从复制的常见拓补结构有哪些？

- 一主多从
- 树状主从结构
- 主主结构

#### 984.在 Redis 集群中，如何根据键定位到对应的节点？

Redis 集群将数据分布到 16384 个哈希槽中，每个键通过哈希函数计算出槽位编号，根据编号定位到具体的节点。

## 7.锁

#### 655.Redis 中如何实现分布式锁？

通过 set ex nx 命令和 lua 脚本组合使用来实现。保证了安全解锁和意外情况下锁的自动释放。

#### 656.分布式锁在未完成逻辑前过期怎么办？

锁过期了可能会导致数据不一致的问题。可以在逻辑完成前**定期续期锁**，确保所在处理过程中不会过期。

#### 657.Redis 的 RedLock 是什么？你了解吗？



#### 658.Redis 实现分布式锁时可能遇到的问题有哪些？



#### 659.Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？



#### 6305.说说 Redisson 分布式锁的原理？



## 8.场景、业务

#### 634.Redis 通常应用于哪些场景？

1. **缓存**
   - Redis 最常用的场景是作为缓存层，减轻数据库负载，提高读取速度。比如，用户会话数据可以存在 Redis 中。
2. **实时系统**
   - Redis 的数据读取和写入都非常快速，非常适合实时系统。比如，实时排行榜。
3. **分布式锁**
   - 可以利用 Redis 实现分布式锁，确保分布式系统的安全访问。
4. **计数器**
   - Redis 的原子性操作非常适合用作计数器。比如，统计点赞数、评论数等。

#### 662.如何使用 Redis 快速实现排行榜？



#### 663.如何使用 Redis 快速实现布降过滤器？



#### 664.如何使用 Redis 统计大量用户唯一访问量（UV）？



#### 666.你在项目中使用的 Redis 客户端是什么?



## 9.命令

#### 837.Redis 中原生批处理命令（MSET、MGET）与 Pipeline 的区别是什么？



#### 880.Redis List 类型的常见操作命令有哪些？

