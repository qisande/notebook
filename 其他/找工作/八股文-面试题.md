# 设计模式

#### 1123.什么是设计模式？请简述其作用。

设计模式是软件开发人员根据经验总结的一套通用代码设计方案。熟悉了设计模式，遇到类似场景，可以快速找到代码实现模板，加快开发速度，提高代码的可扩展性、可重复性和可维护性。

作用：

1. 帮助快速解决常见问题
2. 提高代码可扩展性
3. 提高代码可重复性
4. 提高代码可维护性
5. 减少沟通成本
6. 提供最佳实践

#### 1124.23种设计模式分为哪三大类？

1. 创建型

   用来创建对象的，隐藏对象创建的逻辑，简化代码。

   常见的有：单例模式、工厂模式和建造者模式

2. 结构型

   用来处理对象组合的关系，关注类和对象的组合。

   常见的有：适配器模式、桥接模式、组合模式和装饰器模式

3. 行为型

   用来定义对象之间的相互协作，以此完成单个对象无法完成的任务。

   常见的有：责任链模式、迭代器模式、观察者模式、状态模式、策略模式和模板模式。

#### 1483.什么是单一职责原则？

单一职责原则是面向对象设计的五大原则之一（SOLID）的 S。

核心思想是：一个类或模块只负责完成一个职责，要设计功能单一即粒度小的类，而不是大而全的类。

作用：

1. 提高系统的可扩展性和灵活性
2. 提高代码的可复用性
3. 降低类的复杂性

#### 1372.什么是开闭原则？

开闭原则是面向对象设计的五大原则之一（SOLID）的 S。

核心思想是：对扩展开放，对修改关闭。新增功能只需要新增代码，不需要修改其他的代码，不会破坏原有的逻辑实现。

#### 1373.什么是里氏替换原则？

里氏替换原则是面向对象设计的五大原则之一（SOLID）的 O。

核心思想是：子类对象可以替换父类对象出现的任何地方，保证程序逻辑正常且不会被修改。目的是为了保持兼容性的前提下扩展和修改。

#### 1374.什么是接口隔离原则

接口隔离原则是面向对象设计的五大原则之一（SOLID）的 L。

核心思想是：调用者不应该被迫依赖它不使用的方法，即一个类对另一个类的依赖应该建立在最小接口上。

作用：

1. 提高代码的可读性
2. 减少代码的冗余
3. 提高系统的可扩展性和维护性

#### 1375.什么是依赖倒置原则

依赖倒置原则是面向对象设计的五大原则之一（SOLID）的 D。

核心思想是：

1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象。
2. 抽象不应该依赖细节，细节应该依赖抽象。

#### 1376.什么是迪米特法则

迪米特法则，又称为最少知识原则。

核心思想是：

1. 一个对象应尽量少的了解其他对象的内部细节。
2. 一个对象应该只与直接的朋友通信，不与朋友的朋友通信。

作用：

1. 降低耦合度
2. 提高系统的可维护性
3. 提高代码的可复用性

#### 1416.谈谈你了解的最常见的几种设计模式，说说他们的应用场景

最常用的就是：单例模式、工厂方法模式、策略模式和模板方法模式

比如支付场景，有支付宝和微信等不同的支付渠道。对于全局配置类和全局缓存等，可以使用单例模式。对于支付服务而言，可以定义一个支付接口，让不同的渠道分别去实现接口，这就是策略模式。整个支付流程包括前置处理、支付动作和后置处理等，这时可以使用模板方法模式。定义一个抽象类，实现前置处理和后置处理等通用流程。把支付的核心动作做成抽象方法，让不同渠道分别去实现。

# Java 基础

#### 451.Java 中的序列化和反序列化是什么？

序列化就是将对象转换为字节流的过程，这样对象就可以进行网络传输和持久化存储等。

反序列化就是将字节流重新转换为对象的过程，即从存储中读取数据并重新创建对象。

#### 416.什么是 Java 中的不可变类？

创建后不可修改的类，一旦对象被创建，它的所有属性都不能被更改。

1. 声明类为 final。
2. 声明所有字段为 private 和 final。
3. 不提供相关的 set 方法。

#### 417.Java 中 Exception 和 Error 有什么区别？

Exception 和 Error 都是 Throwable 类的子类

Exception 表示可以被处理的异常。具体又分为

编译器异常，必须被显式的处理。

运行时异常，不需要被显式捕获。

Error 表示系统级的不可恢复的错误，不应该被捕获或处理。

#### 410.你认为 Java 的优势是什么？

1. Java 是跨平台的，可以做到一次编写多平台运行。
2. 提供了垃圾回收功能，提升了开发效率。
3. 丰富的生态，包括第三方类库、中间件和框架等。
4. Java 是一种面向对象语言，利用代码的维护和扩展。

#### 411.什么是 Java 的多态特性？

多态是指同一个接口和父类引用变量可以指向不同的对象实例，根据实际的对象执行相应的方法。

#### 412.Java 中的参数传递是按值还是按引用？

是**值传递**。基本数据类型传递的是值的副本，引用数据类型传递的是引用的副本。

#### 414.为什么 Java 不支持多重继承？

主要是因为多继承会产生菱形继承的问题，会产生歧义。

#### 418.Java 面向对象编程与面向过程编程的区别是什么？

面向对象编程，就是把**类或对象**作为基本单元来组织代码。关注对象之间的关系和交互，可扩展性和复用性较好，适合大型项目。

面向过程编程，就是把**函数**作为基本单元来组织代码。关注执行的步骤和顺序，开发简单，适合小型项目。

#### 419.Java 方法重载和方法重写之间的区别是什么？

前者，允许在同一个类中有多个同名方法，只要参数列表不同。

后者，子类在继承父类时，可以重写父类的某个方法，提供不同的实现。

#### 420.什么是 Java 内部类？它有什么作用？

包括成员内部类、静态内部类、匿名内部类和局部内部类。

作用包括：

1. 将逻辑相关的类封装在一起，提高类的内聚性。
2. 内部类可以很方便的访问外部类的成员变量和方法。
3. 对于只在一个地方使用的小类，可以简化代码。
4. 匿名内部类可以广泛用于实现回调函数和事件监听。

#### 421.JDK8 有哪些新特性？

1. 用元空间代替了永久代。
2. 引入了 Lambda 表达式。
3. 引入了日期类。
4. 引入了 Stream 流式接口。
5. 引入了 CompletableFuture 类。

#### 423.Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？



#### 424.Java 的 StringBuilder 是怎么实现的？



#### 425.Java 中包装类型和基本类型的区别是什么？



#### 413.接口和抽象类有什么区别？



#### 426.JDK 和 JRE 有什么区别？



#### 427.你使用过哪些 JDK 提供的工具？



#### 100.Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？



#### 428.Java 中的 hashcode 和 equals 方法之间有什么关系？



#### 429.什么是 Java 中的动态代理？



#### 430.JDK 动态代理和 CGLIB 动态代理有什么区别？



#### 431.Java 中的注解原理是什么？



#### 432.你使用过 Java 的反射机制吗？如何应用反射？



#### 433.什么是 Java 的 SPI（ServiceProviderinterface）机制？



#### 434.Java 泛型的作用是什么？



#### 6306.Java 泛型擦除是什么？



#### 435.什么是 Java 泛型的上下界限定符？



#### 436.Java 中的深烤贝和浅烤贝有什么区别？



#### 437.什么是 Java 的 Integer 缓存池？



#### 438.Java 的类加载过程是怎样的？

总的来看分为五个阶段：

1. **加载**
   - 将二进制流读入到内存中，生成一个 class 对象。
2. **验证**
   - 验证二进制流是否符合规范。
3. **准备**
   - 为静态变量赋初始值，也即在方法区中划分空间。
4. **解析**
   - 将常量池的符号引用转化为直接引用。
5. **初始化**
   - 执行一些静态代码块，为静态变量赋值。

#### 440.什么是 Java 的 BigDecimal？



#### 441.使用 newString("yupi”）语句在 Java 中会创建多少个对象？



#### 442.Java 中 final、finally 和 finalize 各有什么区别？



#### 443.为什么在 Java 中编写代码时会遇到乱码问题？



#### 422.JDK9 中将 String 的 char 数组改为 byte 数组？



#### 825.如何在 Java 中调用外部可执行程序或系统命令？



#### 938.如果一个线程在 Java 中被两次调用 start() 方法，会发生什么？



#### 941.栈和队列在 Java 中的区别是什么?



#### 942.Java 的 Optional 类是什么？它有什么用？



#### 943.Java 的 I/O 流是什么？



#### 945.什么是 Java 的网络编程?



#### 948.Java 中的基本数据类型有哪些？



#### 949.什么是 Java 中的自动装箱和拆箱？



#### 988.什么是 Java 中的选代器（Iterator）？



#### 989.Java 运行时异常和编译时异常之间的区别是什么？



#### 992.什么是 Java 中的继承机制？



#### 993.什么是 Java 的封装特性？



#### 994.Java 中的访问修饰符有哪些？



#### 995.Java 中静态方法和实例方法的区别是什么？



#### 990.Java 中 for 循坏与 foreach 循坏的区别是什么？



#### 439.什么是 Java 中的双亲委派模型？

是类加载机制的设计模式之一，核心思想是：类加载器在加载某个类时，会先委派给父类加载器去加载，如果无法加载，才会由当前加载器去加载。

#### 5900.Java 中 wait() 和 sleep() 的区别？



#### 5907.Java 和 Go 的区别?



#### 5908.Java Obiect 类中有什么方法，有什么作用?



#### 5909.Java 中的字节码是什么?



#### 166.什么是 BIO、NIO、AIO？



#### 718.什么是 Channel？



#### 720.什么是 Selector？



# Java 集合

#### 6319.说说 Java 中 HashMap 的原理？

HashMap 是基于哈希表的数据结构，用来存储**键值对**，通过**数组 + 链表 + 红黑树**来处理哈希冲突。使用键的 hashCode() 方法计算哈希值，并通过 (n - 1) & hash 来确定元素在数组中的索引。默认初始容量为 16，负载因子为 0.75，当元素数量超过 12个时，容量会扩容到原来的两倍，并重新分配元素的位置。

#### 4948.使用 HashMap 时，有哪些提升性能的技巧？

1. 合理设置初始容量，避免频繁的扩容操作。
2. 调整负载因子，使得满足具体应用场景的需要。
3. 使用高质量的哈希函数，确保哈希值均匀分布。

#### 4947.什么是 Hash 碰撞？怎么解决哈希碰撞？

有几种方法。

1. **拉链法**
   - 将每个槽的位置变成一个链表，哈希值相同的键存储在同一个链表中。
2. **开放寻址法**
   - 出现碰撞，在寻找下一个可用位置。
3. **再哈希法**
   - 出现碰撞时，使用第二个哈希函数来计算新的索引位置。

#### 4946.Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？

前者是一个线程安全的 List 实现，特性就是写时复制。

优点：

- 读操作无锁，每次写操作都会创建并复制新数组，所以读写不冲突，能提供非常高效的并发读性能。

缺点：

- 写操作开销大，内存消耗大。

后者是一个包装方法，通过对每个方法加锁，来保证线程安全。

优点：

- 简单、方便。

缺点：

- 并发性能低。

#### 444.Java 中有哪些集合类？请简单介绍？

主要分为两大类：Collection 接口和 Map 接口，前者存储对象，后者存储键值对。

Collection 接口又分为 List 接口、Set 接口、Queue 接口。

**List 接口下的实现类为：**

ArrayList：基于动态数组，查询速度快。

LinkedList：基于双向链表，插入、删除速度快。

CopyOnWriteArrayList：线程安全，基于动态数组，写操作开销大，适合读多写少的场景。

**Set 接口下的实现类为：**

HashSet：基于哈希表，元素无序，键唯一，键可以为 null。

TreeSet：基于红黑树，元素有序，键唯一，键不能为 null。

LinkedHashSet：基于链表和哈希表，元素有序，键唯一，键可以为 null。

**Queue 接口下的实现类为：**

PriorityQueue：基于优先级堆，优先级队列，元素按照指定的比较器排序。

ArrayDeque：基于动态数组，双端队列，提供栈的操作方法，不允许值为 null。

**Map 接口下的实现类为：**

HashMap：基于哈希表，键值对无序，键唯一，键和值都可以为 null。适用于需要高性能的场景。

LinkedHashMap：基于链表和哈希表，键值对有序，键唯一，键和值都可以为 null。适用于需要保持键的插入顺序或访问顺序的场景。

ConcurrentHashMap：线程安全，基于哈希表，键值对无序，键唯一，键和值为都不能为 null，适用于高并发环境。

TreeMap：基于红黑树，键值对有序，键唯一，键不能为 null，值可以为 null。适用于需要根据键来排序的场景。

HashTable（老旧，尽量不使用）：线程安全，基于哈希表，键值对无序，键唯一，键和值为都不能为 null。

#### 445.数组和链表在 Java 中的区别是什么？

数组基于连续的内存块，大小是固定的。支持 O(1) 时间的随机访问，插入和删除需要移动数据，时间复杂度为 O(n)。可以用来实现缓存、表格等数据结构。

链表基于不连续的节点，大小可以动态变化。访问元素需要 O(n) 时间，插入和删除时间复杂度为 O(1)。可以用来实现队列，栈等数据结构。

#### 446.Java 中的 List 接口有哪些实现类？

List 接口主要包含 ArrayList、LinkedList、CopyOnWriteArrayList 几个实现类。

#### 9180.Java 中 ArrayList 和 LinkedList 有什么区别？

LinkedList 基于双向链表实现。ArrayList 基于动态数组实现，随机访问时间复杂度为 O(1)，插入和删除时间复杂度为 O(n)，LinkedList 与之相反。

#### 9179.Java ArrayList 的扩容机制是什么？

ArrayList 的初始容量为 10。当发生扩容时，ArrayList 会创建一个新数组，其容量为原数组的 1.5 倍，然后将原数组中的元素复制到新数组中。

#### 448.Java 中的 HashMap 和 Hashtable 有什么区别？

HashMap 是线程不安全的，没有线程同步开销，允许键或值为 null。

Hashtable 是线程安全的，由于方法的同步锁机制，性能低于 HashMap，不允许键或值为 null。

#### 9806.ConcurrentHashMap 和 HashTable 的区别是什么？

HashTable 使用的是单一的锁机制，即对整个哈希表进行同步，效率较低。

ConcurrentHashMap 采用了 CAS + synchronized 的方式，仅锁住特定的冲突节点，锁的粒度更细，性能较高。

#### 449.Java 中的 HashSet 和 HashMap 有什么区别？

HashSet 基于 HashMap 来实现，仅操作 HashMap 中键的部分，用于存储唯一元素。

HashMap 用来存储键值对，键唯一，值可以重复。

#### 451.Java 中 HashMap 的扩容机制是怎样的？

扩容是基于**负载因子**来决定的，默认为 0.75。也就是说，元素数量超过容量的 75% 时，会触发扩容。触发扩容时，容量会扩大为原来的**两倍**。且需要重新计算所有元素的哈希值，并将它们重新分配到新的哈希桶中。

#### 452.为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？

主要是为了提高哈希值的**分布均匀性**和哈希计算的**效率**。只有容量为 2 的 n 次方时，才能将 hash % n 转换为 (n - 1) & hash，而**位运算的效率高于取模运算**。

#### 453.为什么 Java 中 HashMap 的默认负载因子是 0.75？

避免过多扩容的同时，也保证了不会出现过多的哈希冲突。为了在**时间复杂度**和**空间复杂度**之间取得平衡。

#### 455.为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？

当哈希冲突较多时，链表中的元素增多，查找、插入和删除的时间复杂度从 O(1) 退化为 O(n)，效率较低。

链表长度大于等于 8 时转换为红黑树，小于等于 6 时退化为链表。红黑树是一种平衡二叉搜索树，查找、插入和删除的时间复杂度为 O(logn)，在元素多的情况下，效率远优于链表。

#### 456.JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？

1. **改进了哈希函数的计算**，使得哈希值分布更加均匀。
2. **优化了扩容机制**，不再对每个元素计算哈希值。
3. **头插法变成尾插法**，避免死循环。

#### 457.Java 中的 LinkedHashMap 是什么？

继承自 HashMap 并且保留了键值对的插入顺序或访问顺序，内部通过维护一个双向链表来实现。

#### 458.Java 中的 TreeMap 是什么？

基于红黑树实现，可以通过自定义比较器，使得节点根据你定义的规则进行排序。

#### 459.Java 中的 ldentityHashMap 是什么？

是 Map 接口的一个实现类，使用引用相等性作为键的比较方式。只有两个键的引用相同时，才被认为是相同的键。

#### 460.Java 中的 WeakHashMap 是什么？

是一个特殊的 Map 实现，它使用**弱引用**作为键。当一个键不再被其他对象引用时，会自动删除与该键相关的条目。

#### 461.Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？

JDK 1.7 采用的是**分段锁**，而 JDK 1.8 移除了分段锁，只在节点级别上进行加锁。进一步减少了锁的竞争，并发度大大增加。

#### 462.Java 中 ConcurrentHashMap 的 get 方法是否需要加锁？

不需要加锁，通过 volatile 关键字，ConcurrentHashMap 能够确保 get 方法的线程安全。即时在写入发生时，读取线程仍然能够获取最新的数据。

#### 463.为什么 Java 的 ConcurrentHashMap 不支持 key 或 value 为 null？

为了避免混淆和潜在的并发问题，同时简化实现。使用 get(key) 方法时，如果返回值为空，无法区分是 key 不存在，还是 value 为 null。

#### 464.Java 中的 CopyOnWriteArrayList 是什么？

是一个线程安全的动态数组实现。通过写时复制机制，即在每次写入操作时，复制原始数组的内容，修改副本。读取的是原始数组，所以读操作无锁。写操作完成后，将新数组代替旧数组。

#### 465.你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？

它通常在集合被遍历的时候，出现修改操作时被抛出。是为了保证集合迭代时语义的一致性。

# Java 并发

## 概念

#### 469.线程的生命周期在 Java 中是如何定义的？

1. **New（初始状态）**：线程对象已创建，但还未调用 start() 方法。
2. **Runnable （可运行状态）**：调用 start() 方法后，线程进入就绪状态，等待 CPU 调度。
3. **Blocked（阻塞状态）**：线程试图获取一个对象锁而被阻塞。
4. **Waiting（等待状态）**：线程进入等待状态，需要被显式的唤醒才能继续执行。
5. **Timed Waiting（含等待时间的等待状态）**：线程进入等待状态，但指定了等待时间，超时后会被唤醒。
6. **Terminated（终止状态）**：线程执行完毕或者因为异常退出。

#### 468.什么是协程？Java 支持协程吗？

是一种**轻量级线程**，可以在执行中暂停并在之后恢复。协程是**用户态调度**，不涉及上下文切换，效率更高。

在 Java 19 中通过 Project Loom 引入了协程，并在 Java 21 中确认。

#### 478.什么是 Java 的 Timer？

是一个用于调度任务的工具类，用来周期性执行任务或定时执行任务。

#### 498.说说 AQS 吧？

AbstractQueuedSynchronizer（抽象队列同步器），就是起到了一个抽象和封装的作用，将一些排队、入队、加锁、中断等方法提供出来，便于其他相关的 JUC 锁的使用，具体加锁时机、入队时机等都需要实现类自己控制。

#### 500.什么是 Java 的 CAS（Compare-And-Swap）操作？

是一种**硬件级别的原子操作**，它比较某个只是否是预期值，如果是，则更新为新值，否则不做修改。

#### 501.什么是 Java 内存模型（JVM）？

是 Java 虚拟机定义的一种规范，规范了线程何时会从主内存中读取数据，何时会把数据写回到主内存中。

目的是确保多线程环境下的**可见性、有序性和原子性**。

#### 502.什么是 Java 中的原子性、可见性和有序性？

1. 原子性指一个或一系列操作要么全部执行成功，要么全部不执行。
2. 可见性指当一个线程修改了某个共享变量的值，其他线程能立即看到这个修改。
3. 有序性指程序的执行顺序和代码的执行顺序一致。

#### 503.什么是 Java 的 happens-before 规则？

他通过定义一系列操作之间的执行顺序，确保线程间的操作是有序的。

#### 504.什么是 Java 中的指令重排？

是指为了优化性能，在保证单线程语义不变的情况下，对指令执行顺序进行调整的过程。

#### 520.什么是 Java 中的 ABA 问题？

是指在多线程环境下，某个变量的值经历了从 A 到 B 再到 A 的变化，可能会被线程误认为该值没有变化，从而导致错误的判断和操作。

## 同步与异步、通信

#### 944.什么是 Java 中的线程同步？

在多线程环境下，避免多个线程对共享资源进行同时访问，导致数据不一致的情况。主要通过对关键代码加锁来实现。如果没有同步机制，可能导致**竞态条件**。

> *竞态条件：由于线程执行顺序不一致，导致不可预期的结果。*

#### 487.如何在 Java 中控制多个线程的执行顺序？

有多种办法。

1. 利用 CompletableFuture 的 thenRun() 方法，依次将任务传入其中即可。
2. 通过 synchronized 和 wait()、notify() 方法的组合。
3. 通过线程池，仅设置一个线程来执行任务，依次将任务提交到线程池中。

#### 470.多线程之间如何进行通信？

通信是指多个线程协同工作。实现方式：

1. **共享变量**：
   - 线程可以通过访问共享内存变量来交换信息。
2. **同步机制**：
   - synchronized：同步关键字，确保同一时刻只有一个线程可以访问共享资源。在利用 Object 类提供的 wait()、notify()、notifyAll() 来实现线程之间的等待与通知机制。
   - BlockingQueue：通过阻塞队列来实现生产者和消费者模式。

#### 5919.Java 中如何创建多线程？

1. 实现 **Runnable 接口** 的 run() 方法。使用 Thread 类的构造方法传入 Runnable 对象，调用 start() 方法启动线程。
2. 继承 **Thread 类**，并重写 run() 方法，创建 Thread 对象，调用 start() 方法启动线程。
3. 使用**线程池**，通过 ExecutorService 提交 Runnable 或 Callable 任务。
4. 使用 **CompletableFuture**，可以很方便的进行异步任务的调用。

#### 517.Java 中的 wait、notify 和 notifyAII 方法有什么作用？

他们都需要在 **synchronized 修饰的方法或同步块**中使用。

wait()：使当前线程进入等待状态，且释放锁。

notify()：顺序唤醒一个调用 wait() 后等待的线程。

notifyAll()：唤醒所有调用 wait() 等待的线程。

## ThreadLocal

#### 506.为什么在 Java 中需要使用 ThreadLocal？

1. 避免了多线程同时访问和修改变量共享，而带来的线程安全问题。
2. ThreadLocal 不需要对变量访问进行同步，减少了上下文切换、锁竞争的性能损耗。

#### 507.Java 中的 ThreadLocal 是如何实现线程资源隔离的？

每个线程内部维护了一个 ThreadLocalMap，它以 ThreadLocal 作为键，以变量副本作为值。不同线程通过 ThreadLocal 获取各自的变量副本。

#### 509.为什么 Java 中的 Threadlocal 对 key 的引用为弱引用？

> **弱引用**（Weak Reference）是一种特殊类型的引用，用于在垃圾回收机制中管理对象的生命周期。
>
> ### 弱引用的特点
>
> 1. **不阻止垃圾回收**：如果一个对象只有弱引用存在，垃圾回收器会在进行垃圾回收时清理该对象。与此相对，强引用会阻止对象被回收。
> 2. **使用场景**：弱引用通常用于实现缓存、监听器、或者避免内存泄漏等场景。例如，可以使用弱引用来缓存一些不太重要的对象，以便在内存紧张时能被回收。

可以防止内存泄漏。弱引用允许垃圾回收器在内存不足时回收对象，当没有其他强引用指向 ThreadLocal 时，它可以被及时回收。

#### 510.Java 中使用 ThreadLocal 的最佳实践是什么？

1. 不用滥用
   - 对于能通过参数传递的上下文信息，不应该使用 ThreadLocal。
2. 避免内存泄漏
   - 需要在适当的时机调用 remove() 方法来清除 ThreadLocal 的值。
3. 使用静态变量存放 ThreadLocal
   - 确保在线程的生命周期内都可以被访问到，避免对象频繁创建。

#### 511.Java 中的 InheritableThreadLocal 是什么？

是 ThreadLocal 的一个扩展，用于在线程创建时将父线程的变量副本传递给子线程。它解决了 ThreadLocal 无法在子线程中继承父线程本地变量的问题。

#### 512.ThreadLocal 的缺点？

正常使用是没什么问题的，数据比较多时可能会出现：

1. 内存泄漏问题。
2. ThreadLocalMap 的效率低。
3. ThreadLocal 主动清理的开销问题。

#### 514.为什么 Netty 不使用 Threadlocal 而是自定义了一个 FastThreadlocal？

1. Threadlocal 的实现使用了弱引用，而 FastThreadlocal 的实现更轻量级，减少了内存分配的开销。
2. 使用了更高效的数据结构来存储线程局部变量，从而提供高快的访问速度。
3. 提供了更好的线程隔离和数据隐私，防止线程之间的数据污染。

#### 515.什么是 Java 的 TransmittableThreadLocal？

是一种扩展了 Java 的 Threadlocal 的功能的类，主要解决了在多线程环境下，如何将局部变量从一个线程传递到另一个线程的问题。

#### 516. Java中 Thread.sleep（o）的作用是什么？

使得 CPU 资源短暂的空闲出来让别的线程有机会得到 CPU 资源。

#### 5918.Java 中 Thread.sleep 和 Thread.yield 的区别？

Thread.sleep 使线程进入阻塞状态，让出 CPU 资源。

Thread.yield 线程依然处于 RUNNABLE 状态，提示当前线程愿意让出 CPU 资源，操作系统的线程调度器可以忽略。

## 线程池

#### 472.你了解 Java 线程池的原理吗？

线程池是一种池化技术，用于预先创建并管理一组线程，避免频繁创建和销毁线程的开销。

工作原理：

1. 任务提交后创建线程。
2. 核心线程满了之后，将任务提交到工作队列。
3. 工作队列满了之后新增线程，直到最大线程数。
4. 线程数满了，工作队列也满了，来新任务后会执行拒绝策略。
5. 如果线程空闲时间超过了空闲存活时间，并且线程数超过了核心线程数，则销毁线程直到核心线程数。

#### 474.如何合理地设置 Java 线程池的线程数？

CPU 密集型：CPU 核心数 + 1

I/O 密集型：CPU 核心数 * 2

#### 475.Java 线程池有哪些拒绝策略？

默认是抛出异常，或者有调用者线程执行，或者删除最早提交的任务，或者直接丢弃。

还可以自定义，实现 RejectedExecutionHandler 类的 rejectedExecution 的方法。

#### 476.Java 并发库中提供了哪些线程池实现？它们有什么区别？

Executors 类提供了五种静态工厂方法用于创建不同类型的线程池。

FixedThreadlocal 线程数固定。适合负载稳定、任务数量确定的场景。

CachedThreadlocal 线程数量没有上限，空闲线程会在 60 秒后被回收。适合短期大量并发任务的场景。

SingleThreadlocal 只有一个线程处理任务。适合需要保证任务按顺序执行的场景。

ScheduledThreadlocal 处理完自己的任务后去其他线程的队列中窃取任务。适合大量小任务并行执行。

#### 5931.Java 线程池核心线程数在运行过程中能修改吗？如何修改？

可以使用 ThreadPoolExecutor.setCorePoolSize() 方法动态修改核心线程数，不会中断现有任务。

#### 5901.Java 线程池中 shutdown 与 shutdownNow 的区别是什么？

>**线程池生命周期：**
>**运行状态**（RUNNING）：线程池可以接受新任务并处理已提交的任务。
>**关闭状态**（SHUTDOWN）：通过调用shutdown() 进入，该状态下线程池不再接受新任务，
>但会继续执行已有的任务
>**停止状态**（STOP）：通过调用shutdownNow() 进入，该状态下线程池会试图中断所有正在执
>行的任务并清空任务队列。
>**终止状态**（TERMINATED）：所有任务执行完毕且线程池完全关闭后，线程池进入
>TERMINATED状态。

shotdown() 启动线程池的平滑关闭。不再接受新任务，但会继续执行已提交的任务。

shotdownNow() 启动线程池的强制关闭。尝试定制所有正在执行的任务。

#### 5896.Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？

提交任务时使用 submit() 方法，而不是 execute() 方法。这样可通过 Future 对象捕获异常。

#### 477.Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？

核心原理差不多，实现优先级队列的方式不一样。

DelayQueue 是阻塞队列，通过 PriorityQueue 来实现优先级队列。

ScheduledThreadPool 是线程池，通过 RunnableScheduledFuture 来实现优先级队列。

## 线程安全

#### 466.java 中的线程安全是什么意思？

**线程安全**是指多个线程访问共享资源时，能够保证一致性和正确性。即无论线程如何交替执行，程序都能产生预期的结果。

#### 505.Java 中的 final 关键字是否能保证变量的可见性？

不可以。在并发情况下的可见性是指一个线程修改了共享变量，另一个线程可以立马得知修改，得到最新修改后的值。 valitile 才可以保证这种情况。

#### 519.Java 中 volatile 关键字的作用是什么？

保证变量的可见性和禁止指令重排序优化。

#### 6304.在 Java 中主线程如何知晓创建的子线程是否执行成功？

1. 使用 Thread.join() 
2. 使用 Callable 和 Future 类
3. 使用回调机制
4. 使用 CountDownLatch 类

## 锁

#### 491.synchronized 和 Reentrantlock 有什么区别？

synchronized 是 Java 内置的关键字，实现基本的同步机制。

ReentrantLock 是 JUC 类库提供的，支持的功能比较多。

简单情况下用 synchronized 就可以，复杂情况下用 ReentrantLock。

#### 492.Java 的 synchronized 是怎么实现的？

**synchronized 修饰方法时**，方法的常量池会增加一个 ACC_SYNCHRONIZED 标志，当某个线程访问这个方法时，检查是否有这个标志。如果有，则需要获得监视器锁，才可执行方法。

**synchronized 修饰代码块时**，会在代码块的前后插入 monitorenter 和 monitorexit 字节码指令，来实现同步。

#### 493.Java 中的 synchronized 轻量级锁是否会进行自旋？

轻量级锁 CAS 失败了之后，不会有自旋操作，会直接进入重量级锁膨胀过程。

#### 494.当 Java 的 synchronized 升级到重量级锁后，所有线程都释放锁了，此时它还是重量级锁吗？

当重量级锁释放后，锁对象是无锁的。有新的线程来竞争的话又会从轻量级锁开始。

#### 495.什么是 Java 中的锁自适应自旋？

> **操作系统的同步原语**：
>
> **互斥量（Mutex）**：用于保护共享资源，保证同一时刻只有一个线程访问资源。
>
> **信号量（Semaphore）**：用于控制多个线程对资源池的访问，适用于有限资源的并发控制。
>
> **读写锁（Read-Write Lock）**：用于读多写少的场景，允许并发读，串行写。
>
> **条件变量（Condition Variable）**：用于线程间的等待和通知机制。
>
> **屏障（Barrier）**：确保多个线程在某一时刻同步执行。
>
> **事件（Event）**：线程间的通知机制，用于等待和响应特定条件。
>
> **原子操作（Atomic）**：不可分割的操作，用于实现无锁算法和高效的线程间同步。

是 Java 中锁优化的一种机制，用于减少线程在**竞争锁时频繁挂起和恢复的开销**。

原理：在锁争用较少的情况下，线程在进入等待状态前，先执行一段自旋操作，而不是立刻挂起线程。

#### 496.如何优化 Java 中的锁的使用？

1. **减少锁的粒度**，比如将一个大对象锁拆分成多个小对象锁，还有对于读多写少的场景使用读写锁。
2. **减少锁的使用**，比如使用 ThreadLocal 来代替共享变量，使用原子类来避免使用锁。

#### 497.Java 中 ReentrantLock 的实现原理是什么？

基于 AQS 实现的一个可重入锁。利用 CAS 修改 state 来争抢锁，争抢不到则进入同步队列等待，条件不满足则进入等待队列等待。

#### 499.你了解 Java 中的读写锁吗？

读写锁分为读锁和写锁。

**读锁**：是共享锁，允许多个线程同时获取读锁。

**写锁**：是独占锁，当有线程获取写锁时，其他线程既不能获取写锁，也不能获取读锁。

#### 518.Java 中什么情况会导致死锁？如何避免？

1. 互斥条件
   - 每个资源只能被一个线程占用。
2. 占有和等待
   - 线程在持有一个资源的同时，等待获取其他资源。
3. 不可抢占
   - 线程获取的资源在未使用完毕前不能被其他线程抢占。
4. 循环等待
   - 多个线程形成一种头尾相接的等待资源的关系。

避免死锁的方法

- 按序申请资源
- 减少锁的范围
- 使用尝试锁机制
- 设置超时等待时间
- 避免嵌套锁

## 并发工具类

#### 480.你使用过哪些 Java 并发工具类？

ConcurrentHashMap, Atomicinteger等

ConcurrentHashMap 

- 是一个现成安全的哈希表，用法和哈希表差不多。

Atomicinteger

- 提供了对 int 类型的线程安全的原子操作，比如增减和比较。

#### 481.什么是 Java 的 Semaphore？

是一个同步工具类。可以限制同时访问特定资源的线程数量。

#### 482.什么是 Java 的 CyclicBarrier？

是一个同步工具类。允许一组线程在执行某个任务时相互等待，直到所有线程都到达屏障之后才继续执行。

#### 483.什么是 Java 的 CountDownLatch？

是一个同步工具类。允许一个或多个线程等待，直到其他线程中执行的一组操作完成。

#### 484.什么是 Java 的 StampedLock？

是一个锁机制，通过引入乐观读锁和时间戳的概念，提高了读写性能。

#### 485.什么是 Java 的 CompletableFuture？

是一个异步编程工具，可以通过链式调用来组合异步操作。

#### 486.什么是 Java 的 ForkJoinPool？

是一个专门用于并行执行任务的线程池，核心机制为分解和合并。

- **Fork（分解）**：任务被递归分解为更小的子任务。
- **Join（合并）**：子任务执行完毕后将结果合并。

算法：空闲线程会从繁忙线程的工作队列中**窃取**未完成的任务，以保持资源的高效利用。

## 场景

#### 479.你了解时间轮（TimeWheel）吗？有哪些应用场景？

是一种用于管理和调度**大量定时任务**的数据结构，它是一种高效的定时任务调度算法。

- 网络服务器中用来处理连接超时和请求超时等。
- 分布式系统中用来协调不同节点的定时任务。

#### 488.你使用过 Java 中的哪些阻塞队列？

当队列满了插入操作会被阻塞，当队列空了获取操作会被阻塞。常用于实现**生产者和消费者**场景。

- ArrayBlockingQueue：一个有界队列，底层基于数组实现。
- LinkedBlockingQueue：允许可选的界限，底层基于链表实现。

#### 489.你使用过 Java 中的哪些原子类？

1. AtomicInteger：用于操作整数的原子类，提供自增、自减和加法等操作。
2. AtomicReference：用于操作对象引用的原子类，支持对原子对象的引用更新。

#### 490.你使用过 Java 的累加器吗？

LongAdder：适用于 Long 类型的累加操作。

DoubleAdder：适用于 Double 类型的累加操作。

# Java 虚拟机

> #### STW
>
> *是一种 JVM 机制，用于在执行某些操作时暂停所有应用线程，从而确保 JVM 在不被干扰的情况下完成某些关键操作。*
>
> 
>
> #### TLAB（Thread-Local Allocation Buffer）
>
> ***TLAB** 是 **Thread-Local Allocation Buffer** 的缩写，意为**线程本地分配缓冲区**。TLAB 是一种分配在年轻代 Eden 区域中的内存空间，用于减少多线程分配对象时的竞争，提升对象分配的效率。*
>
> #### 工作原理：
>
> - *每个线程在 Eden 区域中分配一块私有的 TLAB 空间，这块内存仅供该线程使用。*
> - *当线程需要分配对象时，直接在自己的 TLAB 中分配，无需进行同步操作，这样可以减少锁竞争并提升分配速度。*
> - *当 TLAB 的空间耗尽时，线程会申请一个新的 TLAB。如果 Eden 区域内存不足，可能会触发 Minor GC（小规模垃圾回收）。*
>
> #### 优点：
>
> - ***减少锁竞争**：由于每个线程都有自己的分配缓冲区，分配对象不需要锁，避免了多线程同时访问 Eden 区时的同步开销。*
> - ***提升分配速度**：TLAB 使得对象分配基本上变为线程本地的操作，相当于一种栈分配，因此速度接近原生的栈分配。*
>
> #### TLAB 使用的场景：
>
> *TLAB 适用于年轻代的对象分配，尤其是频繁创建短生命周期的对象场景，例如临时变量、局部对象等。这些对象往往会在年轻代快速分配和回收。*
>
> 
>
> ### PLAB（Promotion Local Allocation Buffer）
>
> ***PLAB** 是 **Promotion Local Allocation Buffer** 的缩写，意为**晋升本地分配缓冲区**。PLAB 用于优化对象从年轻代晋升到老年代时的分配效率，减少在老年代分配对象的开销。*
>
> #### 工作原理：
>
> - *在垃圾回收过程中（特别是 Minor GC），当对象在年轻代存活时间较长或空间不足时，可能会晋升到老年代。*
> - *为了避免多个对象同时晋升到老年代时产生的竞争，JVM 为每个垃圾回收线程分配一个 PLAB 空间。*
> - *每个垃圾回收线程在执行晋升时，先在自己的 PLAB 中分配空间，不需要与其他线程竞争。如果 PLAB 空间不足，则会申请新的 PLAB。*
>
> #### 优点：
>
> - ***提升晋升效率**：PLAB 将对象晋升到老年代时的分配变成了线程本地操作，避免了 GC 线程间的竞争。*
> - ***减少 GC 线程间的锁竞争**：在多线程 GC 中，每个 GC 线程都有独立的 PLAB，从而在分配老年代空间时减少了锁竞争和等待时间。*
>
> #### PLAB 使用的场景：
>
> *PLAB 主要用于垃圾回收过程中晋升存活对象时的分配，适合应用于老年代对象分配，尤其是在对象晋升频繁的场景下。*

## 内存

#### 523.JVM 的内存区域是如何划分的？

1. **虚拟机栈**（JVM Stack）
   - 线程私有。用来存放局部变量表、操作数栈、常量池引用，方法出口信息等。
2. **堆**（Heap）
   - 线程共享。用来存放对象和数组，是垃圾回收的主要区域。
3. **方法区**（Method Area）
   - 线程共享。用来存放类信息、常量、静态变量、JIT 编译后的代码。
4. **本地方法栈**（Native Method Stack）
   - 线程私有。用来存放本地接口对应的代码。
5. **程序计数器**（Program Counter Register）
   - 线程私有。用来存放字节码指令的地址和行号。

除此之外，还有一个 JVM 之外的**直接内存**（Direct Memory）。

- 由 NIO 库通过 ByteBuffer 直接分配的内存，不受堆内存大小限制。

#### 524.Java 中堆和栈的区别是什么？

栈（Stack）：用来存储局部变量和方法的调用信息。在方法执行期间局部变量被创建在栈上，在方法结束时被销毁。

堆（Heap）：用来存储对象实例和数组。

#### 525.什么是 Java 中的直接内存？

是由操作系统分配的内存区域，不受 JVM 堆内存管理限制，可以绕过垃圾回收机制，直接与本地系统内存交互。

#### 526.什么是 Java 中的常量池？

是一块用来存储运行是的常量和符号的区域，主要包括**运行时常量池**和**字符串常量池**。

作用：

- 用于减少对象的重复创建，节省内存并提高效率。

#### 527.你了解 Java 的类加载器吗？

作用：

1. **动态加载类**：在运行时根据需要加载类，而不是在编译时加载所有类。
2. **隔离不同的类命名空间**：通过不同的类加载器可以隔离不同类。

#### 529.什么是 Java 的 JIT（Just-In-Time）？

是一种**在程序运行时将字节码编译为机器码的技术**。减少解释执行的开销，使得 Java 代码接近本地代码的性能。

#### 530.什么是 Java 的 AOT（Ahead-Of-Time）？

提前编译，是一种在程序运行之前，将字节码直接编译为机器码的技术。可以提高程序启动速度。

#### 531.你了解 Java 的逃逸分析吗？

是 Java 编译器的优化技术，即分析对象是否会逃逸出当前**方法或线程的作用范围**。如果不会逃逸，则可以实现**栈上分配、标量替换、同步消除**等优化。

#### 532.Java 中的强引用、软引用、弱引用和虚引用分别是什么？

强引用：垃圾回收器不会回收强引用指向的对象。

软引用：系统内存不足时才会回收软引用指向的对象，适用于缓存。

弱引用：垃圾回收器会立即回收弱引用指向的对象，适合防止内存泄漏。

虚引用：仅用于跟踪对象的回收。

## 垃圾收集器

#### 538.Java 中有哪些垃圾回收算法

标记-清除（Mark-Sweep）：首先遍历堆中的对象，标记出所有存活的对象，最后清除未标记的对象。

标记-复制（Mark-Copying）：将内存分为两半，将存活的对象从一半复制到另一半，清除原区域的所有对象。

标记-整理（Mark-Compact）：首先标记出所有存活的对象，将它们往边界整理，最后清除为标记的对象。

#### 543.JVM 的 TLAB（Thread-LocalAllocation Buffer）是什么

是 JVM 中为每个线程分配的一小块堆内存，避免多线程竞争共享堆内存，加速内存分配。

#### 521.Java 是如何实现跨平台的？

Java 程序在编译后生成字节码文件，对应的操作系统都有各自实现的 JVM，负责将字节码翻译为特定平台的机器码并执行。

#### 9807.JVM 有哪些部分组成？

主要由类加载器、运行时数据区、执行引擎、本地方法接口组成。

#### 522.编译执行与解释执行的区别是什么？JVM 使用哪种方式

**编译执行**：在程序执行之前，通过编译器将源代码编译成机器码，然后直接在 CPU 上运行。

**解释执行**：在程序运行时，通过编译器将源代码逐行翻译并执行。

JVM 采用编译执行和解释执行相结合的方式。程序初次运行时，通过 JVM 逐行解释执行字节码。之后，在程序运行时，通过 **JIT（即时编译器）将热代码**编译为机器码，避免反复解释，提高性能。

#### 533.Java 中常见的垃圾收集器有哪些？

新生代垃圾收集器：

1. Serial 收集器
   - 适用于单线程应用和客户端模式
2. ParNew 收集器
   - 适用于多线程环境，通常配合 CMS 使用。
3. Parallel Scavenge 收集器
   - 适用于大规模运算密集型后台任务，适合对吞吐量要强较高的场景。

老年代垃圾收集器：

1. Serial Old 收集器
   - 适合单线程、低内存使用场景
2. Parallel Old 收集器
   - 适合大规模并行计算场景

3. CMS 收集器
   - 适用于对响应时间要求较高的平台
4. G1 收集器
   - 用于取代 CMS，适用于大内存、多 CPU 服务器应用。
5. ZGC 收集器
   - 适用于对延迟要求极高的场景。

#### 534.Java 中如何判断对象是否是垃圾？不同垃圾回收方法有付区别？

主要有两种方式：

1. **引用计数法**
   - 每个对象维护一个引用计数器，引用增加时，计数器加 1；减少时，计数器减 1。

2. 可达性分析算法
   - 从一组 GC root 出发，遍历所有可以到达的对象，凡是无法到达的，均被视为垃圾。

#### 535.为什么 Java 的垃圾收集器将堆分为老年代和新生代？

> **堆的分代机制，根据对象生命周期被划分为三部分**
>
> - 新生代（YoungGeneration）：存放新创建的对象。
>
> - 老年代（ColdGeneration）：存放存活时间较长的对象，通常是从新生代晋升过来的对象
>
> - 元空间（Metaspace）（JDK8 以前为永久代，JDK8 之后为元空间）：存放类的元数据信
>   息，包括类的静态变量、方法等。
>
> **新生代进一步划分为三个区域：**
>
> - Eden 区：所有新创建的对象百先分配到 Eden 区。
>
> - Survivor 区：Eden 区中的存活对象会被复制到 Survivor 区（一般分为两个区域，S0 和 
>   S1），经过多次 GC 存活的对象会逐渐晋升到老年代。
>
> 新生代中采用**复制算法**，每次垃圾回收时，将 Eden 和 Survivor 中的存活对象复制到另一
> Survivor空间效率高且避免内存碎片
>
> **老年代的作用：**
>
> 老年代用于存放生命周期较长的对象，通常是从新生代普升过来的。老年代使用的回收算法不同于
> 新生代，常用标记-清除算法或标记-整理算法，适合回收长生命周期的对象。

大多数对象存活时间短，放到**新生代**中，回收使用复制算法。少部分对象存活时间长，放到**老年代**中，回收使用标记-整理算法。这样可以更高效的来管理不同生命周期的对象。

#### 536.为什么 Java8 移除了永久代（PermGen）并引入了元空间（Metaspace）？

主要是为了解决永久代固定大小、容易导致内存溢出、GC 效率低的问题。元空间使用本地内存，具备更灵活的内存分配能力，提升了内存管理效率。

#### 537.为什么 Java 新生代被划分为 S0、S1 和 Eden 区？

主要是为了提高新生代内存的利用率。

#### 539.什么是三色标记算法？

是现代垃圾回收器中常用的一种**增量标记算法**，可以与应用程序并发执行，用于标记哪些对象需要被回收，哪些对象需要保留。

#### 540.Java 中的 young GC、old GC、full GC 和 mixed GC 的区别是什么？

young GC：仅针对新生代，回收频率较高，回收时间较短。

old GC：仅针对老年代，回收时间较长。

full GC：针对整个堆内存，回收时间最长，对性能有较大影响。

mixed GC：回收新生代和部分老年代，结合了 YGC 的快速回收和 OGC 的深度回收。适用于大内存应用。

#### 541.什么条件会触发 Java 的 youngGc？

1. Eden 区空间不足
2. Eden 区 + Survivor 区空间都不足

#### 542.什么情况下会触发 Java 的 FullGC？

1. 老年代空间不足。
2. 元空间空间不足。
3. 调用 System.gc() 命令。

#### 544.什么是 Java 的 PLAB？

是垃圾回收其中的一种优化机制，主要用于 G1 垃圾收集器。G1 为每个 GC 线程分配一个局部缓冲区，每个线程可以直接在本地 PLAB 中直接进行对象晋升操作，而不要竞争全局老年代的内存空间。

#### 545.JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？

这是使用 CMS 垃圾回收器时的一种失败现象。CMS 收集器与应用程序并发进行，如果在 CMS 的并发回收阶段，还没有及时清理出足够的空间来满足新对象的分配，就会出现错误。

#### 546.为什么 Java 中 CMS 垃圾收集器在发生 Concurrent Mode Failure 时的 Full GC 是单线程的？

因为没有足够的开发资源。

#### 547.为什么 Java 中某些新生代和老年代的垃圾收集器不能组合使用？比如 ParNew 和 Parallel Old？

HotSpot VM 自身的分代收集器实现有一套框架，只有在框架内的实现才能互相搭配使用。

#### 548.JVM 新生代垃圾回收如何避免全堆扫描？

1. **卡表（Card Table）机制**：使用卡表来记录老年代引用新生代的指针变化，再进行新生代回收时，只扫描那些卡表中记录的老年代对象。
2. **写屏障（Write Barrier）**：当老年代引用新生代对象时，写屏障会拦截这种引用，并在卡表中标记相关信息。

#### 549.Java 的 CMS 垃圾回收器和 G1 垃圾回收器在记忆集的维护上有什么不同？

> 记忆集就是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

CMS 的记忆集即卡表，是通过写屏障维护的。

G1 才用了多层次的记忆集维护机制，每个 Region 都有自己的记忆集，维护成本较高。

#### 550.为什么 G1 垃圾收集器不维护年轻代到老年代的记忆集？

因为年轻代的 region 都在手机范围内，因此不需要额外记录。

#### 551.Java 中的 CMS 和 G1 垃圾收集器如何维持并发的正确性？

CMS 和 G1 分别通过增量更新和 SATB 来维持 GC 线程和应用线程并发的正确性。

#### 552.什么是 Java 中的 logging write barrier？

是一种与 GC 相关的机制，主要用于追踪和记录对象引用的变化。

#### 553.Java 的 G1 垃圾回收流程是怎样的？

分为两大阶段，分别是并发标记和对象拷贝。

并发标记分为初始阶段、并发阶段、最终标记、清理阶段。

然后根据标记结果选择合适的 region 组成收集集合，最后将存货对象拷贝到新的 region 中。

#### 554.Java 的 CMS 垃圾回收流程是怎样的？

分为几大阶段，分别为初始标记、并发标记、并发预清理、可中断的预清理阶段、重新标记、并发清理、并发重置。

#### 555.你了解 Java 的 ZGC（ZGarbageCollector）吗？

ZGC 是 Java 11 引入的低延迟垃圾回收器，目的在支持大内存的应用程序，并保持短的 GC 停顿时间。

其特点为：

1. 并发收集：收集过程大部分是在应用程序运行的同时进行的
2. 指针压缩：使用指针压缩技术，减少内存占用。
3. 极小停顿：停顿时间通常在毫秒级。

## 调优

#### 557.MVM 垃圾回收调优的主要自标是什么？

1. 最短暂停时间：首要目标是减少应用的停顿时间。在垃圾回收时，尽量保持应用的响应能力。
2. 高吞吐量：在单位时间内完成更多的业务处理。

两者基本上不可兼得，所以调优的时候要明确目标。

#### 558.如何对 Java 的垃圾回收进行调优？

核心思路就是尽可能使对象在年轻代被回收，减少对象进入老年代。

根据 GC 日志具体分析，需要关注的指标是 Young GC 和 Full GC 的触发频率、原因、晋升的速率、老年代内存占用量等。

比如频繁发生 Full GC，又没有内存泄露，只是 Young GC 后大量对象进入老年代，则可以适当调大 Survivor 的空间。

#### 559.常用的 JVM 配置参数有哪些？

-Xms：初始化堆内存大小

-Xmx：最大堆内存大小

-XX:MetaspaceSize：初始化元空间大小

-XX:MaxMetaspaceSize：最大元空间大小

-Xss：每个线程的栈大小

-XX:+PrintGCdetails：打印详细的垃圾回收日志

-XX:+UseG1GC：启用 G1 垃圾收集器

-XX:+UseZGC：启用 ZGC 垃圾收集器

#### 560.你常用哪些工具来分析 JVM 性能？

jmap：用于分析 JVM 内存使用情况，尤其是内存泄漏问题。

jstack：用于分析线程状态，排查死锁。

jstat：用于分析实时的性能数据。

Arthas：一个强大的 Java 诊断工具，提供了实时监控和分析功能。

#### 561.如何在 Java 中进行内存泄漏分析？

1. 利用 jstat 命令来观察 GC 概要信息，发现 GC 后 内存占用并没有明显减少，说明内存泄漏的概率很大。
2. 利用 jmap 命令生成 heap dump，将其导入 VisualVM 工具内进行分析，通过大量的内存占用找到对应的对象。
3. 通过对象找到对应的代码来分析，最终修复代码。

# MySQL

## 1.优势

#### 1477.自比于 Oracle，MySQL 的优势有哪些？

1. **MySQL 是免费的。**
2. MySQL 是开源的，有广泛的社区支持和丰富的资料。
3. MySQL 占用资源少，更加轻量。

## 2.优化

#### 1476.为什么不推荐在 MySQL 中直接存储图片、音频、视频等大容量内容？

MySQL 是关系型数据库，**设计的初衷是为了处理结构化和关系型数据**，因此在这方面能力不足。

大容量内容应该存储到文件系统或对象存储系统中，仅在数据库中存储文件的 URL 即可。

#### 629.为什么在 MySQL 中不推荐使用多表 JOIN？

1. **可能会导致性能下降**
   - 在处理大数据集的时候，计算复杂度显著上升，需要进行大量的扫描和匹配，消耗大量的 CPU 和内存资源，增加了响应时间。
2. **可读性和可维护性差**
   - 语句比较复杂，使得后续的调试和优化变得困难。

#### 630.MySQL 中如何解决深度分页的问题？

1. 利用**子查询**扫描二级索引，减少扫描的数据量。
2. 每次分页返回当前的最大 id，下次利用 id 与最大 id 的比较来**过滤**。

#### 4040.MySQL 数据库的性能优化方法有哪些?

优化库表设计、优化 SQL 语句和优化业务。

**库表设计优化**

1. 创建合理的表结构
2. 创建合理的索引，删除不必要的索引。
3. 设计合理的冗余字段，减少关联查询。
4. 对于超大数据量，要考虑分库分表。

> 如何进行 SQL 调优？如何优化慢 SQL？

**查看慢 SQL 日志，利用 EXPLAIN 查询 SQL 的执行计划，找到性能瓶颈，优化 SQL 语句。**

1. 少用 select *，只查询必要字段。
2. 避免在 SQL 中使用函数计算，不然无法命中索引。
3. 避免使用 %LIKE，否则会导致全表扫描。
4. 联合索引要符合最左匹配原则。
5. 不要对无索引的字段进行排序。
6. 进行连表查询时，确保字符集一致，否则会导致全表扫描。

**业务优化**

1. 将频繁查询的数据**缓存**起来。
2. 减少展示不必要的字段。

#### 612.如何使用 MySQL 的 EXPLAIN 语句进行查询分析？

重点看一下查询结果中的几个参数。

- **select_type**：表示查询类型，SIMPLE 代表简单查询、PRIMARY 代表主查询、 SUBQUERY 代表子查询。
- **type**：表示访问类型，REF 代表非唯一索引扫描；RANGE 代表范围扫描，扫描表的一部分；INDEX 代表索引扫描，扫描索引中的所有行；ALL 代表全表扫描，扫描表中的所有行。刚才的顺序为性能从好到差。
- **key**：表示实际用到的索引。
- **rows**：表示大概要读取的行数，行数越少，性能越高。
- **Extra**：表示额外信息，比如显示 using index，表示使用覆盖索引，性能较好。

#### 631.如何在 MySQL 中监控慢 SQL？

利用 MySQL 中的 slow_query_log 参数来监控，它是 MySQL 提供的一个日志功能，用来记录执行时间超过阈值的 SQL 语句。

#### 622.什么是分库分表？分库分表有哪些类型（或策略）？

是**数据库优化性能的一种方法**，通过将数据分散存储在多个数据库和表中，来提高系统的可扩展性、可用性和性能。

1. **垂直分表**
   - 将同一张表的数据按列划分，分散到多个表中。
2. **水平分表**
   - 将同一张表的数据按行划分，分散到多个表中。
3. **垂直分库**
   - 将所有的表按模块划分，分散到多个数据库中。
4. **水平分库**
   - 将相同的表结构复制一份到另一个数据库中。

#### 623.如果组长要求你主导项目中的分库分表，大致的实施流程是？

1. **分析业务需求**
   - 根据数据量以及未来增长趋势，确定到底要不要分库分表。
2. **确定分库分表的方案**
   - 选择合适的分库和分表策略，垂直分，还是水平分。
3. **进行数据路由**
   - 在业务层或者利用数据库中间件，将请求路由到不同的数据库或表。
4. **进行数据迁移**
   - 利用批量导入等方式，将数据导入新的库或表。

#### 624.对数据库进行分库分表可能会引发哪些问题？

1. **首先是事务的问题。**

   - 分库之后单机事务就用不上了，必须使用分布式事务来解决。而分布式事务只能保证最终一致性，所以在**业务上会存在数据不一致的场景**。

2. **连表 JOIN 的问题。**

   - 跨库之后就无法使用 JOIN 了。可以设计冗余字段，来减少关联查询。

3. **全局 ID 唯一性的问题。**

   - 分库分表之后，使用自增 ID 会出现主键重复的情况。可以利用雪花算法来生成唯一 ID。

   > *雪花算法是一种高效且可扩展的生成全局唯一 ID 的方法，适合于大规模分布式系统，确保生成的 ID 唯一且具有时间顺序。*

4. **排序的问题。**

   - 分库分表之后无法使用排序。可以利用数据库中间件的能力来汇总排序。

5. **count 的问题。**

   - 分库分表之后无法使用 count。可以多表 count 后，然后再业务代码中进行累加。

#### 618.如何在 MySQL 中避免单点故障？

一般是采用**主从架构**来避免单点故障，主数据库负责写操作，从数据库负责读操作，主数据库发生故障时，随时切换到从数据库。

**定期备份数据**到不同的物理系统，以便发生故障时能快速恢复。

建立完整的**监控系统**，实时监测数据库的健康状态，发生故障时及时告警。

#### 618.如何在 MySQL 中实现读写分离？

**做法一：代码封装**

使用代理类，对外暴露读写接口，读操作指向从数据库，写操作指向主数据库。

- 优点：简单、灵活。
- 缺点：数据库宕机了，则需要修改配置，重新启动。

**做法二：使用中间件**

客户端连接中间件，中间件连接数据库，它们之间使用 SQL 协议交互。

- 优点：屏蔽了多语言的差异。
- 缺点：需要多维护一个系统，而且可能成为性能瓶颈。

#### 620.什么是 MySQL 的主从同步机制？它是如何实现的？

是一种**数据复制技术**，将主数据库中的数据复制到一个或多个从数据库中。

主要是通过二进制日志（binLog) 实现的。主数据库在进行写操作时，会将操作写入到 binlog 日志中，然后推送给从库。从库重放对应的日志即可完成复制。

#### 621.如何处理 MySQL 的主从同步延迟？

首先无论怎么优化，**延迟是必然存在的**，所以只能减少延迟时间。

1. **二次查询**
   - 如果从库查不到数据，就去主库再查一遍。
2. **关键业务读写都走主库**，非关键业务还是读写分离。
3. **使用缓存**，将数据写入到主数据库后，可以在同步到缓存中，这样查询时可以先从缓存中查。

## 3.实现

#### 617.MySQL中的数据排序是怎么实现的？

如果字段命中索引则使用**索引排序**，反之，使用**文件排序**。

使用文件排序时，如果数据量小，则利用内存排序，分为单路排序和双路排序。

> **双路排序：**
>
> *select 的字段的单行数据大小超过 4kB 时，为了节省排序占用的空间，内存中只会放置主键和要排序的字段，排序后，再通过主键回表查询得到其他字段的值，再将完整的结果集返回。因为需要两次查询，所以叫双路排序。*
>
> **单路排序：**
>
> *一次性所有 select 的字段放到内存中进行排序，没有回表过程，直接返回结果集。*

如果数据量大，则利用磁盘进行外部排序，一般使用归并排序。

#### 3179.如何实现数据库的不停服迁移?

- 首先考虑**量级**，如果是几十万条数据，则用代码迁移，大致比对一下就行了。如果数据量很大，则要好好考虑方案。
- 其次需要考虑**数据的插入和修改**，要保证数据一致性。
- 再然后需要考虑**回滚**，一旦发生意外，要及时切换回旧数据库，保证业务不受影响。

## 4.区别

#### 590.MySQL 的存储引擎有哪些？它们之间有什么区别？

1. InnoDB
   - 支持事务、外键和行级锁。
   - 支持高并发场景，适合高负载的应用。
   - 数据以聚集索引的方式存储，检索性能较高。
2. MyISAM
   - 不支持事务、外键和行级锁，支持表级锁。
   - 适合读取多，更新少的场景，如数据仓库。
   - 具有较高的读性能。

#### 4943.什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？

逻辑删除是指在表中增加一个判断是否删除的字段，如 is_deleted，0 表示未删除，1 表示已删除。

物理删除是指从数据库中删除记录。

#### 4944.什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？

逻辑外键是在**应用程序层面上**利用代码来保证引用的完整性，而不是利用数据库的物理外键。

**逻辑外键：**

优点：

- 灵活性高
- 跨数据库兼容性好

缺点：

- 代码复杂性增加
- 维护成本高

**物理外键：**

优点：

- 减少应用层复杂度
- 自动维护引用完整性

缺点：

- 灵活性差
- 跨数据库兼容性差

#### 615.MySQL 中 varchar 和 char 有什么区别？

都是存储字符串的列类型。

char：固定长度字符串，占用固定的存储空间。字符串长度小于定义的长度时，MySQL **会在字符串后面填充空格**。

varchar：可变长度字符串，占用实际需要的存储空间。字符串需要多 1 到 2 个字节来存储长度信息。

#### 1478.MySQL 中 VARCHAR(100) 和 VARCHAR(10) 的区别是什么？

能存储的**字符串长度上限不同**，前者最多能存储 100 个字符，后者最能存储 10 个字符。

当存储的**字符串相同**时，占用的空间相同。

查询时，前者比后者占用的内存空间更多。

#### 613.MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？

都是**用来统计行数的聚合函数**，但在功能和效率上有些区别。

**功能上：**

1. count(*)  和  count(1)  都是统计全表行数，包括 null。
2. count(字段名) 只统计指定字段不为 null 的行数。

**效率上：**

1. count(*)  和  count(1)  效率一致。
2. count(字段名) 进行的就是全表扫描，还要判断字段是否为 null，所有会比前两个慢。

#### 632.MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？

delete 删除行数据，保留表结构和相关的对象。

drop 删除数据库表，包括表结构和数据。

truncate 删除表数据，保留表结构和索引。

#### 633.MySQL 中 INNER JOIN、LEFT JOIN 和 RIGHT JOIN 的区别是什么？

**inner join：**

- 只返回两个表中匹配的行
- 适用于只关心**交集数据**的场景

**left join：**

- 返回左表中的所有行，如果右表没有匹配的行，则结果中的右侧列为 NULL。
- 适用于需要保留**左表所有数据**的场景。

**right join：**

- 返回右表中的所有行，如果左表没有匹配的行，则结果中的左侧列为 NULL。
- 适用于需要保留**右表所有数据**的场景。

#### 1214.MySQL 中 LIMIT 100000000, 10 和 LIMIT 10 的执行速度是否相同？

执行速度相差很大。

1. LIMIT 100000000, 10

- 需要先处理前1一亿条数据，然后从中获取到需要的10条记录，会造成大量的磁盘 I/O 操作，成本开销很大。

2. LIMIT 10

- 从第一条数据开始记录，获取到需要的 10 条记录。执行速度快。

对于这种大分页的情况，可以先使用主键 id 进行范围过滤。

#### 1217.MySQL 中 DATETIME 和 TIMESTAMP 类型的区别是什么？

datetime：以字符串形式存储，占 8 个字节。不受时区影响，不会根据时区自动转换。

timestamp：以 Unix 时间戳形式存储，占 4 个字节。受时区影响，会根据时区自动转换。

## 5.过程

#### 589.详细描述一条 SQL 语句在MySQL中的执行过程。

连接器 -> 分析器 -> 优化器 -> 执行器

1. 先通过连接器校验权限。
2. 利用分析器进行词法分析和语法分析，构建解析树。
3. 利用优化器选择合适的索引和表连接顺序，最终选择一个最佳的执行计划。
4. 利用执行器调用引擎层查询数据，返回结果集给客户端。

#### 600.请详细描述 MySQL 的 B+ 树中查询数据的全过程

1. 从根节点开始，根据键值选择查左子树还是右子树，最终找到叶子节点。
2. 叶子节点中存储的是实际的数据行记录，每一页有 16kb 大小，存储了很多行数据。
3. 数据行是分组的，根据**页目录**，通过二分查找，找到对应的组。
4. 最后通过链表找到最终的数据行。

## 7.索引

#### 591.MySQL 的索引类型有哪些

从**数据结构**的角度来看：

1. B+树索引
2. 哈希索引
3. 倒排索引
4. R-索引

从**基于 InnoDB B+树索引**角度来看：

1. 聚簇索引
2. 非聚簇索引

从**索引性质**的角度来看：

1. 普通索引
2. 主键索引
3. 联合索引
4. 唯一索引
5. 全文索引
6. 空间索引

#### 601.为什么 MySQL 选择使用 B+ 树作为索引结构？

1. **高效的查询性能**。B+ 树是一种自平衡树，插入、删除和更新等操作的时间复杂度为O(logn)，在数据量较大的情况下，也能有较快的响应。
2. **树的高度增长较慢，查询磁盘 I/O 次数少**。非叶子节点只存储键名和指针，所以索引可以存储更多的数据行。内存中可以存储更多的索引，提高命中缓存的几率，减少查询磁盘 I/O 的次数。
3. **范围查询能力强**。因为叶子节点通过链表链接，只需要顺着链表查询就可以查询到前后的数据，非常高效。

#### 597.在 MySQL 中建索引时需要注意哪些事项？

1. **索引并不是越多越好**，因为索引会占据空间。
2. **字段里的值有大量重复的，最好不要建立索引**。
3. 对于 text、longtext 这些**长字段最好不要建立索引**，因为会占用大量内存。
4. **修改的频率远大于查询的频率时**，最好不要建立索引，因为索引会减慢修改的效率。
5. 当字段作为频繁查询的条件时，最好建立索引。**如果有多个字段，最好建立联合索引**。
6. 对于经常在分组、排序和去重后面的字段，最好建立索引。

#### 598.MySQL 中使用索引一定有效吗？如何排查索引效果？

**不一定有效**，有些情况下就没用上索引，比如：

1. 查询条件中的列不在索引中，或者查询条件复杂且与索引顺序不匹配。
2. 查询的表比较小，全表扫描的效率更高。

总之，用不用索引，是 MySQL 评估 CPU 和 I/O 成本，计算后决定的。

**排查索引效果**可以在执行的 SQL 语句前加上 EXPLAIN，可以查看 MySQL 选择的执行计划。主要看 type、key 和 rows 这三个参数。type 为 index 和 range 表示用上了索引；key 不为 null 表示用上了索引；rows 表示评估的扫描量，扫描量越少，响应越快。

#### 599.MySQL 中的索引数量是否越多越好？为什么？

**索引并不是越多越好**，**时间和空间上都是有成本的**。

1. **从时间上来说**。当进行写入操作时，**索引越多需要修改的地方就越多**，意味着时间开销越大。
2. **从空间上来说**。每建立一个二级索引，都需要新建一个 B+ 树，所以索引越多占用空间越大。

#### 594.MySQL 索引的最左前缀匹配原则是什么？

指的是使用**联合索引**的时候，查询条件必须从最左侧开始匹配，如果一个联合索引包含多个字段，查询条件必须包含第一个字段的条件，然后是第二个字段，以此类推。

#### 1479.在什么情况下，不推荐为数据库建立索引？

1. 数据量小的表
2. 频繁修改的表
3. 需要执行大量 select *的表
4. 值大量重复的字段
5. 查询频率低的字段
6. 长文本字段

#### 592.MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？

**聚簇索引**

1. 索引叶子节点存储的是数据行，可以直接访问完整数据。
2. 一个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序。

**非聚簇索引**

1. 索引叶子节点存储的是主键和索引列，需要根据主键再次查询才能访问到完整的数据。
2. 一个表可以有多个非聚簇索引，适合快速访问特定的列。

#### 595.MySQL 的覆盖索引是什么？

是指二级索引中包含了查询需要的所有字段，使查询可以仅通过访问二级索引。

#### 596.MySQL 的索引下推是什么？

是一种减少回表查询的操作，提高查询效率。当 MySQL 使用索引查询数据时，将部分查询条件下放到存储引擎层过滤。减少了从表中读取的数据行，减少了 IO，将本该由 Server 层完成的操作，交给存储引擎层完成，因此叫做“下推”。**索引下推是应用在联合索引上的。**

## 8.事务

#### 602.MySQL 是如何实现事务的？

主要通过**锁、Redo Log、Undo Log 和 MVCC** 来实现事务。

1. 利用锁的机制，实现数据并发修改的控制，实现事务的隔离性。
2. 利用 Redo Log（重做日志）记录事务对数据库的所有更改，再发生崩溃时恢复未提交的更改，实现事务的持久性。
3. 利用 Undo Log（回滚日志）保存数据的历史版本，在事务操作失败时，回滚到之前的版本，实现事务的原子性和隔离性。
4. 利用 MVCC （多版本并发控制）满足未锁定读的需求，实现读已提交和可重复读的两种隔离级别。实现事务的隔离性。

#### 603.MySQL 中长事务可能会导致哪些问题？

1. **阻塞资源**。
   - 常事务持有锁的时间较长，容易导致其他事务在获取相同锁的时候阻塞，增加系统等待时间和影响并发性能。
   - 业务系统会因为常事务的阻塞而阻塞，容易导致其他服务受到影响，从而导致服务全面崩盘，造成严重的线上事故。
2. **造成死锁**。
   - 多个事务可能在等待对方互相释放锁，造成系统无法继续执行。
3. **主从延迟。**
   - 主数据库执行很长时间后，才能同步数据给从库，在这个长时间的等待中会造成数据的不同步。
4. **浪费时间**。
   - 常事务可能执行了很长时间后因为异常导致失败，那么之前的执行就都浪费了。

#### 604.MySQL 中的 MVCC 是什么？

是一种并发控制机制，允许多个事务同时进行读取和写入的操作，不会阻塞，提高并发性能。

MySQL 会为每一个事务创建一个数据快照，当修改数据时，不会立刻覆盖原数据，而是会生成一个新的有特定版本号的版本记录。

所有的版本记录会串成一条版本链，在不同时刻启动的事务可以**无锁地**获得不同版本的数据，读写操作不会阻塞。

写操作会继续写，无非生成一个新的版本记录，历史版本记录可供已启动的事务读取。

#### 605.如果 MySQL 中没有 MVCC，会有什么影响？

如果没有 MVCC，那么系统就需要频繁的对读写操作加锁，以此来保证数据的一致性。因为增加了获取和释放锁的开销，会导致系统整体响应速度变慢，这种实现叫 LBCC。

#### 606.MySQL 中的事务隔离级别有哪些？

1. **读未提交**
   - 这是最低的隔离级别，一个事务可以会看到另一个事务未提交的数据，可能导致**脏读**问题，即读到其他事务未提交的数据。
2. **读已提交**
   - 一个事务只能看到其他已提交事务的修改。可以避免脏读问题，但是可能会导致**不可重复读**的问题，即同一个事务中相同查询可能返回不同的查询结果。
3. **可重复读**
   - 在同一个事务中多次查询返回的结果相同，可以避免不可重复读的问题。但有可能会导致**幻读**的问题，即多次查询返回不同数量的行。（MySQL 默认）
4. **串行化**
   - 这是最高的隔离级别，每个事务都会等待前一个事务执行完毕后再执行，可以避免所有的并发问题，但会大大降低性能。

#### 607.MySQL 默认的事务隔离级别是什么？为什么选择这个级别？

默认是可重复读。原因是为了兼容早期 binlog 的 statement 格式。如果是使用读未提交和读已提交的话，使用了 statement 的 binlog 会导致主从数据库的数据不一致问题。

#### 1535.你们生产环境的 MySQL 中使用了什么事务隔离级别？为什么?

MySQL 默认的是 RR（可重复读），改成了 RC（读已提交），为了**提高并发量和降低死锁的概率**，因为 RC 中修改数据仅用行锁，锁定的范围更小。

#### 608.数据库的脏读、不可重复读和幻读分别是什么？

1. **脏读**
   - 一个事务读取到另一个事务未提交的修改，如果未提交的事务最终被回滚，那么第一个事务读取到的数据就是不一致的。
2. **不可重复读**
   - 例如，事务 A 读取了一行数据，事务 B 修改并提交了这行数据，导致事务 A 再次读取时得到不同的值。
3. **幻读**
   - 事务 A 查询某条件的记录，事务 B 插入了新的记录并提交，导致事务 A 再次查询时看到不同的记录数量。

## 9.锁

#### 609.MySQL 中有哪些锁类型？

1. **共享锁**
   - 允许事务并发访问同一个资源，不允许修改。只有释放共享锁后，其他事务才能获得排他锁。
2. **排他锁**
   - 只允许一个事务对资源进行读写操作，其他事务在获得排他锁之前无法访问。

3. **行级锁**
   - 加在特定的行上，允许其他事务并发访问不同的行，适用于高并发场景。

4. **表级锁**
   - 加在特定的表上，其他事务无法对该表进行任何的读写操作，适用于小型表。

5. **间隙锁**
   - 加在索引的两个记录之间的间隙，防止其他事务对这个间隙插入新记录，以避免幻读。

6. **临键锁**
   - 是行级锁和间隙锁的结合，锁定具体行和其前面的间隙，常用于可重复读的隔离级别。

7. 意向锁
   - 用于表示某个事务对某行数据加锁的意图，分为意向共享锁和意向排他锁。主要用于行级锁和表级锁的结合。

8. 插入意向锁
   - 一种特殊的意向锁，用于表示某个事务对某个间隙插入记录的意图。

9. 自增锁
   - 再插入自增列时，加锁以保证自增值的唯一性。

#### 610.MySQL 的乐观锁和悲观锁是什么？

**悲观锁：**

- 假设会发生冲突，因此在操作数据之前就**对数据加锁**，防止其他事务进行读写操作。用在对数据一致性要求较高的场景。
- 实现方式：利用行级锁或表级锁。

**乐观锁：**

- 假设不会发生冲突，因此在操作数据之前不加锁，而是在更新数据时**进行版本控制或校验**。发现其他事务修改了数据，则放弃当前事务的本次修改，需重新尝试。
- 实现方式：利用版本号或时间戳进行校验，每次更新时检查版本号或时间戳是否一致。

#### 611.MySQL 中如果发生死锁应该如何解决？

**自动检测与回滚：**

- MySQL 自带死锁自动检测机制，检测到发生死锁时，选择其中一个事务进行回滚，以解除死锁。
- 当获取锁等待时间超过阈值时，就释放锁进行回滚。

**手动 kill 发生死锁的语句**

- 可以通过命令手动快速查询发生阻塞的事务和线程 ID，手动 kill 掉线程，以释放资源。

## 10.是什么

#### 1219.数据库的三大范式是什么？

**第一范式（1NF）**

- 不允许重复的列和多值字段。

**第二范式（2NF）**

- 非主键字段必须依赖于整个主键。

**第三范式（3NF）**

- 非主键字段只能依赖于主键，不能相互依赖。

#### 593.MySQL 中的回表是什么？

“回表“是指在使用”二级索引作为条件进行查询时，由于二级索引中只存储了索引列的值和主键，没有其他数据，如果要得到其他数据，需要根据主键去聚簇索引查询实际的数据行，**这个过程被称为“回表”。**

#### 614.MySQL 中 int(11) 的 11 表示什么？

11 表示**显示宽度**，表示并不影响存储大小和显示范围。

**显示宽度**：使用 ZEROFILL 参数时，如果字段的位值不满 11 位，则前面会填充 0。

**存储大小**：int 类型始终占 4 个字节。

#### 625.MySQL 获取数据，是从磁盘读取的吗？

**并不总是直接从磁盘读取的**，MySQL 有缓存机制。当查询数据时，如果内存中有，则访问内存返回数据，否则从磁盘读取数据并加载到缓存中。

#### 626.MySQL的 Change Buffer 是什么？它有什么作用？

它是 InnoDB 的一个机制，**用于暂存对二级索引的插入和更改操作**，不立即执行这些操作，当条件合适时，InnoDB 会把这些更改写入到二级索引中。

作用：

1. **提高性能**：因为更改被暂存，减少了对磁盘的频繁写入，提高了性能。
2. **批量处理**：Change Buffer 会在后续的操作中批量处理这些更改，减少了随机写入的开销。

#### 627.MySQL 的 DoublewriteBuffer 是什么？它有什么作用？

是 InnoDB 引擎的一个机制，一个内存缓冲区，用来保证数据的安全性和一致性。

**工作原理：**

- 写入：当使用事务向数据库写入数据时，会先写入 Doublewrite Buffer 中，然后从缓冲区中将数据写入到磁盘的实际文件中。
- 恢复：写入磁盘的过程中，发生断电等意外情况时，将数据从 Doublewrite Buffer 中恢复到实际文件中。

#### 628.MySQL 中的 Log Buffer 是什么？它有什么作用？

是一个内存区域，用来暂存事务日志的数据。通过批量写入操作将日志数据一次性写入到磁盘中，减少 I/O 操作，提高性能。

#### 1418.什么是数据库的视图？

是一个**虚拟表**，不存储实际的数据，通过查询其他表的数据来生成。包含一个或多个表的数据，可以对这些数据进行筛选、计算和排序操作。使用视图可以增强数据的安全性。

#### 1419.什么是数据库的游标？

是一个**数据库对象**，使得应用程序可以逐行访问查询结果集，而不是一次性处理所有结果。

## 11.其他

#### 1376.在 MySQL 中，你使用过哪些函数？

字符串函数：length、concat、substring等。

#### 1377.MySQL 中 TEXT 类型最大可以存储多长的文本？

**tinytext：**255 字节。

**text：**64kB 字节。

**mediumtext：**16MB 字节。

**longtext：**4GB 字节。

#### 1378.MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？

达到最大值后，会继续申请下一个 ID，值不变，导致报重复值的错误。

#### 1379.在MySQL中存储金额数据，应该使用什么数据类型？

bigint 和 decimal，**bigint 在代码中对应 long，decimal 在代码中对应 BigDecimal**。

#### 1482.MySQL 中 EXISTS 和 IN 的区别是什么？

exists：用于判断子查询是否返回任何行。适用于外层查询表量级小于子查询表，且子表有索引。

in：用于检查某个值是否在指定的集合中。适用于外层查询表量级大于子查询表，且外层表有索引。

#### 1534.什么是 Write-Ahead Logging(WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？

是一种数据库事务日志管理系统，核心思想是，**先写日志，在写数据**。，大致流程如下：

1. 在事务开始时，先将对数据库的修改记录到日志中。
2. 确保日志安全写入磁盘后，再将这些修改应用到数据库文件中。

优点：

- 保证数据一致性。
- 性能提升。

用到了，重做日志（Redo Log）就是 WAL 的实现。

#### 1218.为什么阿里巴巴的 Java 手册不推荐使用存储过程?

1. 可移植性差
2. 调试困难
3. 维护复杂

#### 2629.MySQL 中 InnoDB 存储引擎与 MyISAM 存储引擎的区别是什么？

**MyISAM：**

1. **不支持事务和行级锁，只有表级别锁。**
2. 不支持崩溃后的安全恢复。
3. 写入性能差

**InnoDB：（默认）**

1. 支持事务和行级锁。
2. 支持外键。
3. 并发性能好。

#### 2640.MySQL 的查询优化器如何选择执行计划？

1. 将 SQL 语句解析为解析树。
2. 预处理，比如进行语法检查、校验权限和查询重写。
3. 生成多个执行计划，选择成本最低的。

#### 9498.MySQL 事务的二阶段提交是什么？

是 MySQL 确保 redo log 和 binlog 的一致性而使用的一种机制。主要是为了在崩溃恢复时不会出现**数据丢失和不一致**的情况。

分为**准备和提交两个阶段**，先写 redolog 此时状态为 prepare，再写 binlog，然后再把 redolog 的状态改为 commit。

#### 9499.MySQL 二层 B+ 树能存多少数据？

按每条记录 1 kB 算，每个指针 6 字节，索引键 8 字节，每个节点页大小 16kB，大约能存储 2000 万条记录。

# Redis

## 1.优势

#### 5206.Redis 源码中有哪些巧妙的设计，举几个典型的例子？

巧妙的设计主要包括：线程模型、数据结构、共享对象池、过期设计、数据持久化设计。

- 采用单线程模型，减少上下文切换开销。并使用多路复用和事件驱动机制，来处理大量并发请求。
- 采用动态字符串设计，提高安全性；利用压缩列表来存储数据，节省内存；采用渐进式 rehash 方式，避免了集中的性能抖动。
- 使用共享对象池来存储常用的小整数，减少了内存分配和释放的开销。
- 对于过期键，采用惰性删除确保性能，同时利用定期删除避免内存泄漏。
- 利用 AOF 重写机制来确保数据安全。

#### 635.Redis 为什么这么快？

1. 将数据存储在内存中，提供快速的读写速度。
2. 使用单线程事件驱动模型和 I/O 多路复用技术，减少上下文切换。
3. 提供多种高效的经过优化的数据结构。

#### 640.Redis 和 Memcached 有哪些区别？

Redis 支持多种数据结构，支持持久化功能。

Memcached 仅支持键值对存储，不支持持久化。

## 2.优化、解决问题

#### 646.Redis 中的 BigKey 问题是什么？如何解决？

是一个占用内存空间比较大的键。

**开发方面：**将数据进行压缩之后再存储。

**业务方面：**只存避免数据。

**数据分布方面：**将大 key 拆分散落到不同的服务器上。

#### 647.如何解决 Redis 中的热点 key 问题？

1. 讲热点数据分散到多个 key 中。
2. 使用多级缓存，在 Redis 前增加本地缓存。
3. 利用读写分离，将读请求发送到多个从节点。
4. 访问量过高时应用限流策略，减少对 Redis 的访问。

#### 668.Redis 性能瓶颈时如何处理？

首先是扩容，增加单机 Redis 的内存。其次上 Redis 主从，通过从服务分担压力。在然后就是利用 Redis 集群进行数据分片。

#### 937.Redis 中的内存碎片化是什么？如何进行优化？

指内存使用中出现了小块空间被闲置，无法被有效利用。

最简单的办法就是定期重启。

## 3.实现、原理，功能、机制

#### 638.Redis 中跳表的实现原理是什么?

主要通过**多层链表**实现，底层链表保存所有元素，而每一层都是下一层子集。

- **查找时**，从最高层开始，逐层向下，直到找到目标元素。
- **插入时**，从最高层开始查找插入位置，随机决定新节点层数，然后在相应层插入节点。
- **删除时**，从最高层开始查找删除位置，并更新各层中的指针，保持跳表的结构。

#### 636.为什么 Redis 设计为单线程？6.0 版本为何引入多线程？

1. 性能瓶颈主要不是 CPU 导致的。

2. **减少线程上下文切换带来的开销。**
3. 在单线程下，使用 I/O 多路复用模型就可以提高 I/O 利用率了。

#### 644.Redis 的 Lua 脚本功能是什么？如何使用？

允许用户在服务端执行自定义的 Lua 脚本，以实现原子操作和复杂逻辑。

优点有：**原子性、减少网络传输次数和可以实现复杂操作**。

#### 645.Redis 的 Pipeline 功能是什么？

再一次网络请求中批量发送多个命令。好处：**节省网络传输的时间，减少上下文切换的开销**。

#### 649.Redis 在生成 RDB 文件时如何处理请求？

Redis 生成 RDB 文件的操作时异步的，采用了 fork 子进程的方式来进行快照操作，不会影响正常请求。

#### 654.Redis 的订阅发布功能是什么？你了解吗？

是一种**消息通信机制**，用于在不同客户端之间实时传递消息和广播。

- **发布：**某个客户端想指定的频道发布消息。
- **订阅：**一个或多个客户端订阅频道，通过频道接收该消息。

#### 827.Redis 中 EMBSTR 对象的副值设置为何为 44？其调整历史是什么？

3.2 版本的 sds 使用的是 sdshdr5 结构，之后就不是用这个结构了，相比之前节省了 5 个字节。阈值由 39 变成了 44。

#### 939.Redis 的虚拟内存（VM）机制是什么？

当内存不足时，将冷数据移到磁盘，将热数据保留在内存中。后来就淘汰了，使用了内存淘汰策略来管理内存。

## 4.数据结构

#### 637.Redis 中常见的数据类型有哪些？

常见的数据类型主要有 5 种，分别为：String(字符串)、List(列表)、Hash、Set(集合)、Sorted Set(有序集合)

**String**

字符串是 Redis 种最基本的数据类型，可以存储任何类型的数据。

**使用场景：**

- 缓存：存储用户会话等。
- 计数器：统计点赞数等。

**List**

列表为有序的字符串集合，支持从两端推入和弹出元素。底层实现为双向链表。

**使用场景：**

- 消息队列：用于消息传递等场景。
- 历史记录：用于存储用户的历史记录。

**Hash**

哈希是一个键值对集合，底层实现为哈希表。

**使用场景：**

- 商品详情：存储商品的各个属性。

**Set**

集合是无序且不重复的字符串集合，底层为哈希表。

**使用场景：**

- 标签系统：存储用户的唯一标签，避免重复。

**Sorted Set**

有序集合类似于集合，但每个元素都有一个分数，底层实现为跳表。

**使用场景：**

- 排行榜：实现各种实时排行榜。
- 任务调度：根据任务的优先级排序，方便调度执行。

#### 639.Redis 的 hash 是什么？

是一种**键值对集合**，适合存储对象类型的数据。具有**内存高效和灵活性强**的特点。

负载因子：保存的节点数量 / 哈希表大小

扩容：

- **负载因子大于等于 1 时**。
- 首先创建一个新表，大小大概为旧表的 2 倍。每次进行增删改查操作时，都进行一次数据迁移，**所以扩容是分多次，渐进式完成的**。

缩容：

- 负载因子小于等于 0.1 时。
- 过程与扩容一样。

#### 661.Redis String 类型的底层实现是什么?

主要是基于 **SDS 结构**，并结合 int、embstr、raw 等不同的编码方式优化存储。

#### 665.Redis 中的 Geo 数据结构是什么？

主要用于地理位置信息的存储，底层使用了 Sorted Set，可以进行地理位置的检索、存储和计算距离等操作。

#### 667.Redis 字符串类型的最大值大小是多少？

最大容量是 512 MB。

#### 881.如何在 Redis 中实现队列和栈数据结构？

可以利用 List 类型来实现

- LPUSH 向列表的左侧推入元素，RPOP 从列表的右侧弹出元素，来实现队列。
- LPUSH 向列表的左侧推入元素，LPOP 从列表的右侧弹出元素，来实现栈。

#### 882.Redis 中的 ziplist 和 Quicklist 数据结构的特点是什么？

- ziplist：简单、紧凑、连续存储、节省内存，适合小数据量场景。
- quicklist：将链表和 ziplist 结合，既保留了链表的灵活性，又具备压缩列表的内存优势。

#### 886.Redis 的 ListPack 数据结构是什么？

是一种紧凑型的序列化数据结构。优点包括：内存占用少、高性能和结构简单。

## 5.一致性、事务

#### 641.Redis 支持事务吗？如何实现？

Redis **支持事务**，但与 MySQL 中的事务不一样。

Redis 中的事务主要保证命令执行的原子性，且不支持事务回滚。

MySQL 中的事务主要保证 ACID 的特性，而且支持回滚。

Redis 的事务不是我们理解的传统事务。

#### 642.Redis 数据过期后的删除策略是什么？

分为定期删除和惰性删除两种。

- **定期删除：**Redis 每隔一段时间，随机检查一定数量的键。如果发现过期，则将其删除。
- **惰性删除：**每次访问键的时候，检查是否已过期，如果过期了，则将其删除。

#### 643.Redis 中有哪些内存淘汰策略？

一共有 8 种，分为开启数据淘汰和不开启数据淘汰。不开启数据淘汰又分为全部数据的淘汰策略和基于过期时间的淘汰策略。

不淘汰数据（默认）

- noeviction：运行内存超过设置的内存时，不淘汰数据而是报错，禁止写入。

全部数据的淘汰策略

- allkeys-lru：淘汰掉最久没使用的 key。
- allkeys-lfu：淘汰掉最少使用的 key。
- allkeys-random：随机淘汰任意的 key。

基于过期时间的淘汰策略

- volatile-ttl：优先淘汰掉较早过期的 key。
- 其他和上面一样，只不过是基于过期时间。

#### 648.Redis 的持久化机制有哪些？

RDB

- 通过创建快照来获取内存某个时间点上的副本，定期保存。

AOF

- 将每个写操作追加到日志文件中，比 RDB 机制更加可靠。

#### 660.Redis 中如何保证缓存与数据库的数据一致性？

- 先更新数据库，再删除缓存。后续等查询时再将数据库中的数据回种到缓存中。
- 坚挺数据库的 binlog 变化，通过异步的方式更新缓存。

考虑实时一致性的话使用第一种，考虑最终一致性的话使用第二种。

#### 884.Redis 事务与关系型数据库事务的主要区别是什么？

同 641 题。

## 6.分布式、集群

#### 651.Redis 主从复制的实现原理是什么？

一个主节点讲数据复制到多个从节点，并保持同步。

复制流程：

- **连接：**从节点向主节点发送 PSYNC 命令来建立连接。
- **全量复制：**如果是第一次或之前失败了，则从节点请求全量复制，主节点将数据快照，即 RDB 文件，发送个从节点。
- **增量复制：**之后保持长连接将后续的写操作发送给从节点，来保证数据一致性。

#### 652.Redis 集群的实现原理是什么？

集群是通过多个 Redis 实例组成的，每个实例只存放部分数据。

利用**哈希槽**机制来分配数据。将键值空间划分为 **16384 个槽**，每个节点拥有一部分槽位。每个键值根据哈希算法映射到一个槽位，通过槽位可以找到对应节点。

客户端发送请求到集群中的**任意一个节点**，如果有数据泽直接返回，反之，则根据键值计算哈希槽并路由到正确节点。

#### 650.Redis 的哨兵机制是什么？

是一种高可用性解决方案，用于监控主从集群，**自动完成主从切换**，以此实现故障恢复和通知。

功能：

- **监控**节点的运行状态，检查节点是否正常。
- 主节点发生故障时，**选举出新的主节点**。
- 向其他服务**发送状态通知**。

#### 653.Redis 集群会出现脑裂问题吗？

可能会，特别是在**网络分区**的情况下，同一集群内可能出现多个主节点，导致数据不一致。

#### 883.Redis 复制延识的常见原因有哪些？

- 网络原因，比如网络抖动等。
- 主节点负载过高，来不及向从节点发送复制数据。
- 从节点配置较差。

#### 885.Redis cluster 模式与 Sentinel 模式的区别是什么？

需要处理大量数据并进行数据分片的话，选 Redis Cluster 模式。

为了提高 Redis 实例的可用性，选 主从 + Sentinel 模式。

#### 838.Redis 主从复制的常见拓补结构有哪些？

- 一主多从
- 树状主从结构
- 主主结构

#### 984.在 Redis 集群中，如何根据键定位到对应的节点？

Redis 集群将数据分布到 16384 个哈希槽中，每个键通过哈希函数计算出槽位编号，根据编号定位到具体的节点。

## 7.锁

#### 655.Redis 中如何实现分布式锁？

通过 set ex nx 命令和 lua 脚本组合使用来实现。保证了安全解锁和意外情况下锁的自动释放。

#### 656.分布式锁在未完成逻辑前过期怎么办？

锁过期了可能会导致数据不一致的问题。可以在逻辑完成前**定期续期锁**，确保所在处理过程中不会过期。

#### 657.Redis 的 RedLock 是什么？你了解吗？

Red Lock 又称为红锁，是一种分布式锁的解决方案。利用主从 + 哨兵的分布式锁的实现，当发生主从切换时，**从节点不一定同步了主节点的锁信息**，可能导致数据不一致的问题。红锁就是为了解决这个问题。

#### 658.Redis 实现分布式锁时可能遇到的问题有哪些？

1. 单点故障问题。
2. 业务未执行完，锁已过期。
3. 主从延迟导致的不同步问题。
4. 网络分区问题。
5. 时钟漂移问题。

#### 659.Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？

缓存击穿：

- 概念：**某个热点数据失效**，导致大量请求同时访问数据库。
- 解决方法：使用**互斥锁**，确保同一时间只有一个请求去查询数据库并更新缓存。

缓存雪崩：

- 概念：**多个缓存在同一时期过期**，导致大量请求同时访问数据库。
- 解决方法：随机设置键的**过期时间**，避免多个数据同时过期。

缓存穿透：

- 概念：查询一个**不存在的数据**，缓存中肯定没有，导致每次请求都直接方法数据库。
- 解决方法：使用**布隆过滤器**，过滤掉不存在的请求。

#### 6305.说说 Redisson 分布式锁的原理？



## 8.场景、业务

#### 634.Redis 通常应用于哪些场景？

1. **缓存**
   - Redis 最常用的场景是作为缓存层，减轻数据库负载，提高读取速度。比如，用户会话数据可以存在 Redis 中。
2. **实时系统**
   - Redis 的数据读取和写入都非常快速，非常适合实时系统。比如，实时排行榜。
3. **分布式锁**
   - 可以利用 Redis 实现分布式锁，确保分布式系统的安全访问。
4. **计数器**
   - Redis 的原子性操作非常适合用作计数器。比如，统计点赞数、评论数等。

#### 662.如何使用 Redis 快速实现排行榜？

可以利用 Sorted Set 快速实现。

1. 使用 zadd 命令将用户和对应的分数添加到集合中。
2. 使用 zrank 命令获取某个用户的排名。
3. 使用 zrevrange 获取分数最高的前 N 名。
4. 使用 zincrby 更新分数。

#### 663.如何使用 Redis 快速实现布降过滤器？

1. 利用位图结构的 getbit 和 setbit 操作来实现。

2. 利用 RedisBloom 模块来创建和管理布隆过滤器。

#### 664.如何使用 Redis 统计大量用户唯一访问量（UV）？

可以使用 HyperLogLog 结构，它是一种基数估算算法的概率数据结构。

#### 666.你在项目中使用的 Redis 客户端是什么?

常见的有二种

- Jedis 适合简单的同步操作和单线程环境。
- Redission 适合复杂的分布式系统。

## 9.命令

#### 837.Redis 中原生批处理命令（MSET、MGET）与 Pipeline 的区别是什么？

原生批处理命令单个命令，Pipeline 是一种机制，一次发送多个命令。

#### 880.Redis List 类型的常见操作命令有哪些？

lset 在指定索引的位置设置值。

llen 获取列表长度。

lindex 通过索引获取列表中的元素。

lpush 将一个或多个值插入到列表头部。

rpush 将一个或多个值插入到列表尾部。

lpop 移除并返回列表头部的元素。

rpop 移除并返回列表尾部的元素。

# 场景题

#### 752.假设有一个 1G 大的 HashMap，此时用户请求过来刚好触发它的扩容，会怎样？让你改造下 HashMap 的实现该怎样优化？

会创建一个比之前大两倍的新数组，然后将所有元素搬运到新数组中。所以当前用户请求会被阻塞，等待扩容完毕。

通过渐进式 rehash 来优化。

1. 扩容分多批次完成。
2. 每次插入、修改或查询时，迁移少量旧数据到新数组中。
