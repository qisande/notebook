![image-20250108001509138](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108001509138.png)

![image-20250108001531735](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108001531735.png)

![image-20250108001427226](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108001427226.png)



![image-20250108002005510](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108002005510.png)

![image-20250108003746408](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108003746408.png)



![image-20250108004054960](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108004054960.png)



![image-20250108004137431](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108004137431.png)



![image-20250108004536007](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108004536007.png)



![image-20250108004830533](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108004830533.png)



![image-20250108005538074](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108005538074.png)





![image-20250108010057273](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108010057273.png)





![image-20250108010532748](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108010532748.png)







# 8🌟

#### 598.MySQL 中使用索引一定有效吗？如何排查索引效果？

**不一定有效**，有些情况下就没用上索引，比如：

1. 查询条件中的列不在索引中，或者查询条件复杂且与索引顺序不匹配。
2. 查询的表比较小，全表扫描的效率更高。

总之，用不用索引，是 MySQL 评估 CPU 和 I/O 成本，计算后决定的。

**排查索引效果**可以在执行的 SQL 语句前加上 EXPLAIN，可以查看 MySQL 选择的执行计划。主要看 type、key 和 rows 这三个参数。type 为 index 和 range 表示用上了索引；key 不为 null 表示用上了索引；rows 表示评估的扫描量，扫描量越少，响应越快。

# 7 🌟

#### 1416.谈谈你了解的最常见的几种设计模式，说说他们的应用场景

最常用的就是：单例模式、工厂方法模式、策略模式和模板方法模式

比如支付场景，有支付宝和微信等不同的支付渠道。对于全局配置类和全局缓存等，可以使用单例模式。对于支付服务而言，可以定义一个支付接口，让不同的渠道分别去实现接口，这就是策略模式。整个支付流程包括前置处理、支付动作和后置处理等，这时可以使用模板方法模式。定义一个抽象类，实现前置处理和后置处理等通用流程。把支付的核心动作做成抽象方法，让不同渠道分别去实现。

# 6🌟

![image-20250108012843056](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108012843056.png)

![image-20250108012816276](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108012816276.png)

![image-20250108012916838](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108012916838.png)

![image-20250108012934544](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108012934544.png)

# 5🌟

![image-20250108013225974](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013225974.png)

![image-20250108013242360](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013242360.png)

#### 637.Redis 中常见的数据类型有哪些？

常见的数据类型主要有 5 种，分别为：String(字符串)、List(列表)、Hash、Set(集合)、Sorted Set(有序集合)

**String**

字符串是 Redis 种最基本的数据类型，可以存储任何类型的数据。

**使用场景：**

- 缓存：存储用户会话等。
- 计数器：统计点赞数等。

**List**

列表为有序的字符串集合，支持从两端推入和弹出元素。底层实现为双向链表。

**使用场景：**

- 消息队列：用于消息传递等场景。
- 历史记录：用于存储用户的历史记录。

**Hash**

哈希是一个键值对集合，底层实现为哈希表。

**使用场景：**

- 商品详情：存储商品的各个属性。

**Set**

集合是无序且不重复的字符串集合，底层为哈希表。

**使用场景：**

- 标签系统：存储用户的唯一标签，避免重复。

**Sorted Set**

有序集合类似于集合，但每个元素都有一个分数，底层实现为跳表。

**使用场景：**

- 排行榜：实现各种实时排行榜。
- 任务调度：根据任务的优先级排序，方便调度执行。

#### 659.Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？

缓存击穿：

- 概念：**某个热点数据失效**，导致大量请求同时访问数据库。
- 解决方法：使用**互斥锁**，确保同一时间只有一个请求去查询数据库并更新缓存。

缓存雪崩：

- 概念：**多个缓存在同一时期过期**，导致大量请求同时访问数据库。
- 解决方法：随机设置键的**过期时间**，避免多个数据同时过期。

缓存穿透：

- 概念：查询一个**不存在的数据**，缓存中肯定没有，导致每次请求都直接方法数据库。
- 解决方法：使用**布隆过滤器**，过滤掉不存在的请求。

![image-20250108013542535](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013542535.png)

![image-20250108013559582](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013559582.png)

# 4🌟

#### 448.Java 中的 HashMap 和 Hashtable 有什么区别？

HashMap 是线程不安全的，没有线程同步开销，允许键或值为 null。

Hashtable 是线程安全的，由于方法的同步锁机制，性能低于 HashMap，不允许键或值为 null。

#### 472.你了解 Java 线程池的原理吗？

线程池是一种池化技术，用于预先创建并管理一组线程，避免频繁创建和销毁线程的开销。

工作原理：

1. 任务提交后创建线程。
2. 核心线程满了之后，将任务提交到工作队列。
3. 工作队列满了之后新增线程，直到最大线程数。
4. 线程数满了，工作队列也满了，来新任务后会执行拒绝策略。
5. 如果线程空闲时间超过了空闲存活时间，并且线程数超过了核心线程数，则销毁线程直到核心线程数。

![image-20250108013721475](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013721475.png)

![image-20250108013734680](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013734680.png)

#### 597.在 MySQL 中建索引时需要注意哪些事项？

1. **索引并不是越多越好**，因为索引会占据空间。
2. **字段里的值有大量重复的，最好不要建立索引**。
3. 对于 text、longtext 这些**长字段最好不要建立索引**，因为会占用大量内存。
4. **修改的频率远大于查询的频率时**，最好不要建立索引，因为索引会减慢修改的效率。
5. 当字段作为频繁查询的条件时，最好建立索引。**如果有多个字段，最好建立联合索引**。
6. 对于经常在分组、排序和去重后面的字段，最好建立索引。

#### 606.MySQL 中的事务隔离级别有哪些？

1. **读未提交**
   - 这是最低的隔离级别，一个事务可以会看到另一个事务未提交的数据，可能导致**脏读**问题，即读到其他事务未提交的数据。
2. **读已提交**
   - 一个事务只能看到其他已提交事务的修改。可以避免脏读问题，但是可能会导致**不可重复读**的问题，即同一个事务中相同查询可能返回不同的查询结果。
3. **可重复读**
   - 在同一个事务中多次查询返回的结果相同，可以避免不可重复读的问题。但有可能会导致**幻读**的问题，即多次查询返回不同数量的行。（MySQL 默认）
4. **串行化**
   - 这是最高的隔离级别，每个事务都会等待前一个事务执行完毕后再执行，可以避免所有的并发问题，但会大大降低性能。

#### 635.Redis 为什么这么快？

1. 将数据存储在内存中，提供快速的读写速度。
2. 使用单线程事件驱动模型和 I/O 多路复用技术，减少上下文切换。
3. 提供多种高效的经过优化的数据结构。

![image-20250108013852110](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013852110.png)

![image-20250108013903957](https://images73.oss-cn-beijing.aliyuncs.com/img/image-20250108013903957.png)

#### 6319.说说 Java 中 HashMap 的原理？

HashMap 是基于哈希表的数据结构，用来存储**键值对**，通过**数组 + 链表 + 红黑树**来处理哈希冲突。使用键的 hashCode() 方法计算哈希值，并通过 (n - 1) & hash 来确定元素在数组中的索引。默认初始容量为 16，负载因子为 0.75，当元素数量超过 12个时，容量会扩容到原来的两倍，并重新分配元素的位置。

# 3🌟

475

573

591

604

631

648

660

681

704

741

775

958

1125

2797

4040

5919

6305

9381

# 2🌟

430
432

438
439

444

451

461

474

480

498

527

594

595

601
602

612

622

634

655

710

722
732

894

1084

1130
1131

1140

1219

3617

4681

4947
4949

5619

9180















